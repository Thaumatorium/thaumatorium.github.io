(function(scope) {
  "use strict";
  const F = (arity, fun, wrapper) => {
    wrapper.a = arity;
    wrapper.f = fun;
    return wrapper;
  };
  const F2 = fun => F(2, fun, a => b => fun(a, b));
  const F3 = fun => F(3, fun, a => b => c => fun(a, b, c));
  const F4 = fun => F(4, fun, a => b => c => d => fun(a, b, c, d));
  const F5 = fun => F(5, fun, a => b => c => d => e => fun(a, b, c, d, e));
  const F6 = fun =>
    F(6, fun, a => b => c => d => e => f => fun(a, b, c, d, e, f));
  const F7 = fun =>
    F(7, fun, a => b => c => d => e => f => g => fun(a, b, c, d, e, f, g));
  const F8 = fun =>
    F(8, fun, a => b => c => d => e => f => g => h =>
      fun(a, b, c, d, e, f, g, h)
    );
  const F9 = fun =>
    F(9, fun, a => b => c => d => e => f => g => h => i =>
      fun(a, b, c, d, e, f, g, h, i)
    );
  const A2 = (fun, a, b) => (fun.a === 2 ? fun.f(a, b) : fun(a)(b));
  const A3 = (fun, a, b, c) => (fun.a === 3 ? fun.f(a, b, c) : fun(a)(b)(c));
  const A4 = (fun, a, b, c, d) =>
    fun.a === 4 ? fun.f(a, b, c, d) : fun(a)(b)(c)(d);
  const A5 = (fun, a, b, c, d, e) =>
    fun.a === 5 ? fun.f(a, b, c, d, e) : fun(a)(b)(c)(d)(e);
  const A6 = (fun, a, b, c, d, e, f) =>
    fun.a === 6 ? fun.f(a, b, c, d, e, f) : fun(a)(b)(c)(d)(e)(f);
  const A7 = (fun, a, b, c, d, e, f, g) =>
    fun.a === 7 ? fun.f(a, b, c, d, e, f, g) : fun(a)(b)(c)(d)(e)(f)(g);
  const A8 = (fun, a, b, c, d, e, f, g, h) =>
    fun.a === 8 ? fun.f(a, b, c, d, e, f, g, h) : fun(a)(b)(c)(d)(e)(f)(g)(h);
  const A9 = (fun, a, b, c, d, e, f, g, h, i) =>
    fun.a === 9
      ? fun.f(a, b, c, d, e, f, g, h, i)
      : fun(a)(b)(c)(d)(e)(f)(g)(h)(i);
  var _List_Nil = { $: 0 };
  var _List_Nil_UNUSED = { $: "[]" };
  const _List_Cons = (hd, tl) => {
    return { $: 1, a: hd, b: tl };
  };
  const _List_Cons_UNUSED = (hd, tl) => {
    return { $: "::", a: hd, b: tl };
  };
  var _List_cons = F2(_List_Cons);
  const _List_fromArray = arr => {
    var out = _List_Nil;
    for (var i = arr.length; i--; ) {
      out = _List_Cons(arr[i], out);
    }
    return out;
  };
  const _List_toArray = xs => {
    for (var out = []; xs.b; xs = xs.b) {
      out.push(xs.a);
    }
    return out;
  };
  var _List_map2 = F3((f, xs, ys) => {
    for (var arr = []; xs.b && ys.b; xs = xs.b, ys = ys.b) {
      arr.push(A2(f, xs.a, ys.a));
    }
    return _List_fromArray(arr);
  });
  var _List_map3 = F4((f, xs, ys, zs) => {
    for (var arr = []; xs.b && ys.b && zs.b; xs = xs.b, ys = ys.b, zs = zs.b) {
      arr.push(A3(f, xs.a, ys.a, zs.a));
    }
    return _List_fromArray(arr);
  });
  var _List_map4 = F5((f, ws, xs, ys, zs) => {
    for (
      var arr = [];
      ws.b && xs.b && ys.b && zs.b;
      ws = ws.b, xs = xs.b, ys = ys.b, zs = zs.b
    ) {
      arr.push(A4(f, ws.a, xs.a, ys.a, zs.a));
    }
    return _List_fromArray(arr);
  });
  var _List_map5 = F6((f, vs, ws, xs, ys, zs) => {
    for (
      var arr = [];
      vs.b && ws.b && xs.b && ys.b && zs.b;
      vs = vs.b, ws = ws.b, xs = xs.b, ys = ys.b, zs = zs.b
    ) {
      arr.push(A5(f, vs.a, ws.a, xs.a, ys.a, zs.a));
    }
    return _List_fromArray(arr);
  });
  var _List_sortBy = F2((f, xs) =>
    _List_fromArray(_List_toArray(xs).sort((a, b) => _Utils_cmp(f(a), f(b))))
  );
  var _List_sortWith = F2((f, xs) =>
    _List_fromArray(
      _List_toArray(xs).sort((a, b) => {
        var ord = A2(f, a, b);
        return ord === elm$core$Basics$EQ
          ? 0
          : ord === elm$core$Basics$LT
          ? -1
          : 1;
      })
    )
  );
  const _Utils_eq = (x, y) => {
    for (
      var pair, stack = [], isEqual = _Utils_eqHelp(x, y, 0, stack);
      isEqual && (pair = stack.pop());
      isEqual = _Utils_eqHelp(pair.a, pair.b, 0, stack)
    ) {}
    return isEqual;
  };
  const _Utils_eqHelp = (x, y, depth, stack) => {
    if (depth > 100) {
      stack.push(_Utils_Tuple2(x, y));
      return !0;
    }
    if (x === y) {
      return !0;
    }
    if (typeof x !== "object" || x === null || y === null) {
      typeof x === "function" && _Debug_crash(5);
      return !1;
    }
    if (x.$ < 0) {
      x = elm$core$Dict$toList(x);
      y = elm$core$Dict$toList(y);
    }
    for (var key in x) {
      if (!_Utils_eqHelp(x[key], y[key], depth + 1, stack)) {
        return !1;
      }
    }
    return !0;
  };
  var _Utils_equal = F2(_Utils_eq);
  var _Utils_notEqual = F2((a, b) => !_Utils_eq(a, b));
  const _Utils_cmp = (x, y, ord) => {
    if (typeof x !== "object") {
      return x === y ? 0 : x < y ? -1 : 1;
    }
    if (typeof x.$ === "undefined") {
      return (ord = _Utils_cmp(x.a, y.a))
        ? ord
        : (ord = _Utils_cmp(x.b, y.b))
        ? ord
        : _Utils_cmp(x.c, y.c);
    }
    for (; x.b && y.b && !(ord = _Utils_cmp(x.a, y.a)); x = x.b, y = y.b) {}
    return ord || (x.b ? 1 : y.b ? -1 : 0);
  };
  var _Utils_lt = F2((a, b) => _Utils_cmp(a, b) < 0);
  var _Utils_le = F2((a, b) => _Utils_cmp(a, b) < 1);
  var _Utils_gt = F2((a, b) => _Utils_cmp(a, b) > 0);
  var _Utils_ge = F2((a, b) => _Utils_cmp(a, b) >= 0);
  var _Utils_compare = F2((x, y) => {
    var n = _Utils_cmp(x, y);
    return n < 0
      ? elm$core$Basics$LT
      : n
      ? elm$core$Basics$GT
      : elm$core$Basics$EQ;
  });
  var _Utils_Tuple0 = 0;
  var _Utils_Tuple0_UNUSED = { $: "#0" };
  const _Utils_Tuple2 = (a, b) => {
    return { a: a, b: b };
  };
  const _Utils_Tuple2_UNUSED = (a, b) => {
    return { $: "#2", a: a, b: b };
  };
  const _Utils_Tuple3 = (a, b, c) => {
    return { a: a, b: b, c: c };
  };
  const _Utils_Tuple3_UNUSED = (a, b, c) => {
    return { $: "#3", a: a, b: b, c: c };
  };
  const _Utils_chr = c => c;
  const _Utils_chr_UNUSED = c => new String(c);
  const _Utils_update = (oldRecord, updatedFields) => {
    var newRecord = {};
    for (var key in oldRecord) {
      newRecord[key] = oldRecord[key];
    }
    for (var key in updatedFields) {
      newRecord[key] = updatedFields[key];
    }
    return newRecord;
  };
  var _Utils_append = F2(_Utils_ap);
  const _Utils_ap = (xs, ys) => {
    if (typeof xs === "string") {
      return xs + ys;
    }
    if (!xs.b) {
      return ys;
    }
    var root = _List_Cons(xs.a, ys);
    xs = xs.b;
    for (var curr = root; xs.b; xs = xs.b) {
      curr = curr.b = _List_Cons(xs.a, ys);
    }
    return root;
  };
  var _JsArray_empty = [];
  const _JsArray_singleton = value => [value];
  const _JsArray_length = array => array.length;
  var _JsArray_initialize = F3((size, offset, func) => {
    var result = new Array(size);
    for (var i = 0; i < size; i++) {
      result[i] = func(offset + i);
    }
    return result;
  });
  var _JsArray_initializeFromList = F2((max, ls) => {
    var result = new Array(max);
    for (var i = 0; i < max && ls.b; i++) {
      result[i] = ls.a;
      ls = ls.b;
    }
    result.length = i;
    return _Utils_Tuple2(result, ls);
  });
  var _JsArray_unsafeGet = F2((index, array) => array[index]);
  var _JsArray_unsafeSet = F3((index, value, array) => {
    var length = array.length;
    var result = new Array(length);
    for (var i = 0; i < length; i++) {
      result[i] = array[i];
    }
    result[index] = value;
    return result;
  });
  var _JsArray_push = F2((value, array) => {
    var length = array.length;
    var result = new Array(length + 1);
    for (var i = 0; i < length; i++) {
      result[i] = array[i];
    }
    result[length] = value;
    return result;
  });
  var _JsArray_foldl = F3((func, acc, array) => {
    var length = array.length;
    for (var i = 0; i < length; i++) {
      acc = A2(func, array[i], acc);
    }
    return acc;
  });
  var _JsArray_foldr = F3((func, acc, array) => {
    for (var i = array.length - 1; i >= 0; i--) {
      acc = A2(func, array[i], acc);
    }
    return acc;
  });
  var _JsArray_map = F2((func, array) => {
    var length = array.length;
    var result = new Array(length);
    for (var i = 0; i < length; i++) {
      result[i] = func(array[i]);
    }
    return result;
  });
  var _JsArray_indexedMap = F3((func, offset, array) => {
    var length = array.length;
    var result = new Array(length);
    for (var i = 0; i < length; i++) {
      result[i] = A2(func, offset + i, array[i]);
    }
    return result;
  });
  var _JsArray_slice = F3((from, to, array) => array.slice(from, to));
  var _JsArray_appendN = F3((n, dest, source) => {
    var destLen = dest.length;
    var itemsToCopy = n - destLen;
    if (itemsToCopy > source.length) {
      itemsToCopy = source.length;
    }
    var size = destLen + itemsToCopy;
    var result = new Array(size);
    for (var i = 0; i < destLen; i++) {
      result[i] = dest[i];
    }
    for (var i = 0; i < itemsToCopy; i++) {
      result[i + destLen] = source[i];
    }
    return result;
  });
  var _Debug_log = F2((tag, value) => value);
  var _Debug_log_UNUSED = F2((tag, value) => {
    console.log(tag + ": " + _Debug_toString(value));
    return value;
  });
  const _Debug_todo = (moduleName, region) => message =>
    _Debug_crash(8, moduleName, region, message);
  const _Debug_todoCase = (moduleName, region, value) => message =>
    _Debug_crash(9, moduleName, region, value, message);
  const _Debug_toString = value => "<internals>";
  const _Debug_toString_UNUSED = value => _Debug_toAnsiString(!1, value);
  const _Debug_toAnsiString = (ansi, value) => {
    if (typeof value === "function") {
      return _Debug_internalColor(ansi, "<function>");
    }
    if (typeof value === "boolean") {
      return _Debug_ctorColor(ansi, value ? "True" : "False");
    }
    if (typeof value === "number") {
      return _Debug_numberColor(ansi, value + "");
    }
    if (value instanceof String) {
      return _Debug_charColor(ansi, "'" + _Debug_addSlashes(value, !0) + "'");
    }
    if (typeof value === "string") {
      return _Debug_stringColor(ansi, '"' + _Debug_addSlashes(value, !1) + '"');
    }
    if (typeof value === "object" && "$" in value) {
      var tag = value.$;
      if (typeof tag === "number") {
        return _Debug_internalColor(ansi, "<internals>");
      }
      if (tag[0] === "#") {
        var output = [];
        for (var k in value) {
          if (k === "$") continue;
          output.push(_Debug_toAnsiString(ansi, value[k]));
        }
        return "(" + output.join(",") + ")";
      }
      if (tag === "Set_elm_builtin") {
        return (
          _Debug_ctorColor(ansi, "Set") +
          _Debug_fadeColor(ansi, ".fromList") +
          " " +
          _Debug_toAnsiString(ansi, elm$core$Set$toList(value))
        );
      }
      if (tag === "RBNode_elm_builtin" || tag === "RBEmpty_elm_builtin") {
        return (
          _Debug_ctorColor(ansi, "Dict") +
          _Debug_fadeColor(ansi, ".fromList") +
          " " +
          _Debug_toAnsiString(ansi, elm$core$Dict$toList(value))
        );
      }
      if (tag === "Array_elm_builtin") {
        return (
          _Debug_ctorColor(ansi, "Array") +
          _Debug_fadeColor(ansi, ".fromList") +
          " " +
          _Debug_toAnsiString(ansi, elm$core$Array$toList(value))
        );
      }
      if (tag === "::" || tag === "[]") {
        var output = "[";
        value.b &&
          ((output += _Debug_toAnsiString(ansi, value.a)), (value = value.b));
        for (; value.b; value = value.b) {
          output += "," + _Debug_toAnsiString(ansi, value.a);
        }
        return output + "]";
      }
      var output = "";
      for (var i in value) {
        if (i === "$") continue;
        var str = _Debug_toAnsiString(ansi, value[i]);
        var c0 = str[0];
        var parenless =
          c0 === "{" ||
          c0 === "(" ||
          c0 === "[" ||
          c0 === "<" ||
          c0 === '"' ||
          str.indexOf(" ") < 0;
        output += " " + (parenless ? str : "(" + str + ")");
      }
      return _Debug_ctorColor(ansi, tag) + output;
    }
    if (typeof DataView === "function" && value instanceof DataView) {
      return _Debug_stringColor(ansi, "<" + value.byteLength + " bytes>");
    }
    if (typeof File === "function" && value instanceof File) {
      return _Debug_internalColor(ansi, "<" + value.name + ">");
    }
    if (typeof value === "object") {
      var output = [];
      for (var key in value) {
        var field = key[0] === "_" ? key.slice(1) : key;
        output.push(
          _Debug_fadeColor(ansi, field) +
            " = " +
            _Debug_toAnsiString(ansi, value[key])
        );
      }
      if (output.length === 0) {
        return "{}";
      }
      return "{ " + output.join(", ") + " }";
    }
    return _Debug_internalColor(ansi, "<internals>");
  };
  const _Debug_addSlashes = (str, isChar) => {
    var s = str
      .replace(/\\/g, "\\\\")
      .replace(/\n/g, "\\n")
      .replace(/\t/g, "\\t")
      .replace(/\r/g, "\\r")
      .replace(/\v/g, "\\v")
      .replace(/\0/g, "\\0");
    if (isChar) {
      return s.replace(/\'/g, "\\'");
    } else {
      return s.replace(/\"/g, '\\"');
    }
  };
  const _Debug_ctorColor = (ansi, string) =>
    ansi ? "\x1b[96m" + string + "\x1b[0m" : string;
  const _Debug_numberColor = (ansi, string) =>
    ansi ? "\x1b[95m" + string + "\x1b[0m" : string;
  const _Debug_stringColor = (ansi, string) =>
    ansi ? "\x1b[93m" + string + "\x1b[0m" : string;
  const _Debug_charColor = (ansi, string) =>
    ansi ? "\x1b[92m" + string + "\x1b[0m" : string;
  const _Debug_fadeColor = (ansi, string) =>
    ansi ? "\x1b[37m" + string + "\x1b[0m" : string;
  const _Debug_internalColor = (ansi, string) =>
    ansi ? "\x1b[94m" + string + "\x1b[0m" : string;
  const _Debug_toHexDigit = n => String.fromCharCode(n < 10 ? 48 + n : 55 + n);
  const _Debug_crash = identifier => {
    throw new Error(
      "https://github.com/elm/core/blob/1.0.0/hints/" + identifier + ".md"
    );
  };
  const _Debug_crash_UNUSED = (identifier, fact1, fact2, fact3, fact4) => {
    switch (identifier) {
      case 0:
        throw new Error(
          'What node should I take over? In JavaScript I need something like:\n\n    Elm.Main.init({\n        node: document.getElementById("elm-node")\n    })\n\nYou need to do this with any Browser.sandbox or Browser.element program.'
        );
      case 1:
        throw new Error(
          "Browser.application programs cannot handle URLs like this:\n\n    " +
            document.location.href +
            "\n\nWhat is the root? The root of your file system? Try looking at this program with `elm reactor` or some other server."
        );
      case 2:
        var jsonErrorString = fact1;
        throw new Error(
          "Problem with the flags given to your Elm program on initialization.\n\n" +
            jsonErrorString
        );
      case 3:
        var portName = fact1;
        throw new Error(
          "There can only be one port named `" +
            portName +
            "`, but your program has multiple."
        );
      case 4:
        var portName = fact1;
        var problem = fact2;
        throw new Error(
          "Trying to send an unexpected type of value through port `" +
            portName +
            "`:\n" +
            problem
        );
      case 5:
        throw new Error(
          'Trying to use `(==)` on functions.\nThere is no way to know if functions are "the same" in the Elm sense.\nRead more about this at https://package.elm-lang.org/packages/elm/core/latest/Basics#== which describes why it is this way and what the better version will look like.'
        );
      case 6:
        var moduleName = fact1;
        throw new Error(
          "Your page is loading multiple Elm scripts with a module named " +
            moduleName +
            ". Maybe a duplicate script is getting loaded accidentally? If not, rename one of them so I know which is which!"
        );
      case 8:
        var moduleName = fact1;
        var region = fact2;
        var message = fact3;
        throw new Error(
          "TODO in module `" +
            moduleName +
            "` " +
            _Debug_regionToString(region) +
            "\n\n" +
            message
        );
      case 9:
        var moduleName = fact1;
        var region = fact2;
        var value = fact3;
        var message = fact4;
        throw new Error(
          "TODO in module `" +
            moduleName +
            "` from the `case` expression " +
            _Debug_regionToString(region) +
            "\n\nIt received the following value:\n\n    " +
            _Debug_toString(value).replace("\n", "\n    ") +
            "\n\nBut the branch that handles it says:\n\n    " +
            message.replace("\n", "\n    ")
        );
      case 10:
        throw new Error("Bug in https://github.com/elm/virtual-dom/issues");
      case 11:
        throw new Error("Cannot perform mod 0. Division by zero error.");
    }
  };
  const _Debug_regionToString = region => {
    if (region._.G === region.aj.G) {
      return "on line " + region._.G;
    }
    return "on lines " + region._.G + " through " + region.aj.G;
  };
  var _Basics_add = F2((a, b) => a + b);
  var _Basics_sub = F2((a, b) => a - b);
  var _Basics_mul = F2((a, b) => a * b);
  var _Basics_fdiv = F2((a, b) => a / b);
  var _Basics_idiv = F2((a, b) => (a / b) | 0);
  var _Basics_pow = F2(Math.pow);
  var _Basics_remainderBy = F2((b, a) => a % b);
  var _Basics_modBy = F2((modulus, x) => {
    var answer = x % modulus;
    return modulus === 0
      ? _Debug_crash(11)
      : (answer > 0 && modulus < 0) || (answer < 0 && modulus > 0)
      ? answer + modulus
      : answer;
  });
  var _Basics_pi = Math.PI;
  var _Basics_e = Math.E;
  var _Basics_cos = Math.cos;
  var _Basics_sin = Math.sin;
  var _Basics_tan = Math.tan;
  var _Basics_acos = Math.acos;
  var _Basics_asin = Math.asin;
  var _Basics_atan = Math.atan;
  var _Basics_atan2 = F2(Math.atan2);
  const _Basics_toFloat = x => x;
  const _Basics_truncate = n => n | 0;
  const _Basics_isInfinite = n => n === Infinity || n === -Infinity;
  var _Basics_ceiling = Math.ceil;
  var _Basics_floor = Math.floor;
  var _Basics_round = Math.round;
  var _Basics_sqrt = Math.sqrt;
  var _Basics_log = Math.log;
  var _Basics_isNaN = isNaN;
  const _Basics_not = bool => !bool;
  var _Basics_and = F2((a, b) => a && b);
  var _Basics_or = F2((a, b) => a || b);
  var _Basics_xor = F2((a, b) => a !== b);
  const _Char_toCode = char => {
    var code = char.charCodeAt(0);
    if (0xd800 <= code && code <= 0xdbff) {
      return (code - 0xd800) * 0x400 + char.charCodeAt(1) - 0xdc00 + 0x10000;
    }
    return code;
  };
  const _Char_fromCode = code =>
    _Utils_chr(
      code < 0 || 0x10ffff < code
        ? "\uFFFD"
        : code <= 0xffff
        ? String.fromCharCode(code)
        : ((code -= 0x10000),
          String.fromCharCode(
            Math.floor(code / 0x400) + 0xd800,
            (code % 0x400) + 0xdc00
          ))
    );
  const _Char_toUpper = char => _Utils_chr(char.toUpperCase());
  const _Char_toLower = char => _Utils_chr(char.toLowerCase());
  const _Char_toLocaleUpper = char => _Utils_chr(char.toLocaleUpperCase());
  const _Char_toLocaleLower = char => _Utils_chr(char.toLocaleLowerCase());
  var _String_cons = F2((chr, str) => chr + str);
  const _String_uncons = string => {
    var word = string.charCodeAt(0);
    return word
      ? elm$core$Maybe$Just(
          0xd800 <= word && word <= 0xdbff
            ? _Utils_Tuple2(_Utils_chr(string[0] + string[1]), string.slice(2))
            : _Utils_Tuple2(_Utils_chr(string[0]), string.slice(1))
        )
      : elm$core$Maybe$Nothing;
  };
  var _String_append = F2((a, b) => a + b);
  const _String_length = str => str.length;
  var _String_map = F2((func, string) => {
    var len = string.length;
    var array = new Array(len);
    var i = 0;
    while (i < len) {
      var word = string.charCodeAt(i);
      if (0xd800 <= word && word <= 0xdbff) {
        array[i] = func(_Utils_chr(string[i] + string[i + 1]));
        i += 2;
        continue;
      }
      array[i] = func(_Utils_chr(string[i]));
      i++;
    }
    return array.join("");
  });
  var _String_filter = F2((isGood, str) => {
    var arr = [];
    var len = str.length;
    var i = 0;
    while (i < len) {
      var char = str[i];
      var word = str.charCodeAt(i);
      i++;
      if (0xd800 <= word && word <= 0xdbff) {
        char += str[i];
        i++;
      }
      if (isGood(_Utils_chr(char))) {
        arr.push(char);
      }
    }
    return arr.join("");
  });
  const _String_reverse = str => {
    var len = str.length;
    var arr = new Array(len);
    var i = 0;
    while (i < len) {
      var word = str.charCodeAt(i);
      if (0xd800 <= word && word <= 0xdbff) {
        arr[len - i] = str[i + 1];
        i++;
        arr[len - i] = str[i - 1];
        i++;
      } else {
        arr[len - i] = str[i];
        i++;
      }
    }
    return arr.join("");
  };
  var _String_foldl = F3((func, state, string) => {
    var len = string.length;
    var i = 0;
    while (i < len) {
      var char = string[i];
      var word = string.charCodeAt(i);
      i++;
      if (0xd800 <= word && word <= 0xdbff) {
        char += string[i];
        i++;
      }
      state = A2(func, _Utils_chr(char), state);
    }
    return state;
  });
  var _String_foldr = F3((func, state, string) => {
    var i = string.length;
    while (i--) {
      var char = string[i];
      var word = string.charCodeAt(i);
      if (0xdc00 <= word && word <= 0xdfff) {
        i--;
        char = string[i] + char;
      }
      state = A2(func, _Utils_chr(char), state);
    }
    return state;
  });
  var _String_split = F2((sep, str) => str.split(sep));
  var _String_join = F2((sep, strs) => strs.join(sep));
  var _String_slice = F3((start, end, str) => str.slice(start, end));
  const _String_trim = str => str.trim();
  const _String_trimLeft = str => str.replace(/^\s+/, "");
  const _String_trimRight = str => str.replace(/\s+$/, "");
  const _String_words = str => _List_fromArray(str.trim().split(/\s+/g));
  const _String_lines = str => _List_fromArray(str.split(/\r\n|\r|\n/g));
  const _String_toUpper = str => str.toUpperCase();
  const _String_toLower = str => str.toLowerCase();
  var _String_any = F2((isGood, string) => {
    var i = string.length;
    while (i--) {
      var char = string[i];
      var word = string.charCodeAt(i);
      if (0xdc00 <= word && word <= 0xdfff) {
        i--;
        char = string[i] + char;
      }
      if (isGood(_Utils_chr(char))) {
        return !0;
      }
    }
    return !1;
  });
  var _String_all = F2((isGood, string) => {
    var i = string.length;
    while (i--) {
      var char = string[i];
      var word = string.charCodeAt(i);
      if (0xdc00 <= word && word <= 0xdfff) {
        i--;
        char = string[i] + char;
      }
      if (!isGood(_Utils_chr(char))) {
        return !1;
      }
    }
    return !0;
  });
  var _String_contains = F2((sub, str) => str.indexOf(sub) > -1);
  var _String_startsWith = F2((sub, str) => str.indexOf(sub) === 0);
  var _String_endsWith = F2(
    (sub, str) =>
      str.length >= sub.length &&
      str.lastIndexOf(sub) === str.length - sub.length
  );
  var _String_indexes = F2((sub, str) => {
    var subLen = sub.length;
    if (subLen < 1) {
      return _List_Nil;
    }
    var i = 0;
    var is = [];
    while ((i = str.indexOf(sub, i)) > -1) {
      is.push(i);
      i = i + subLen;
    }
    return _List_fromArray(is);
  });
  const _String_fromNumber = number => number + "";
  const _String_toInt = str => {
    var total = 0;
    var code0 = str.charCodeAt(0);
    var start = code0 == 0x2b || code0 == 0x2d ? 1 : 0;
    for (var i = start; i < str.length; ++i) {
      var code = str.charCodeAt(i);
      if (code < 0x30 || 0x39 < code) {
        return elm$core$Maybe$Nothing;
      }
      total = 10 * total + code - 0x30;
    }
    return i == start
      ? elm$core$Maybe$Nothing
      : elm$core$Maybe$Just(code0 == 0x2d ? -total : total);
  };
  const _String_toFloat = s => {
    if (s.length === 0 || /[\sxbo]/.test(s)) {
      return elm$core$Maybe$Nothing;
    }
    var n = +s;
    return n === n ? elm$core$Maybe$Just(n) : elm$core$Maybe$Nothing;
  };
  const _String_fromList = chars => _List_toArray(chars).join("");
  const _Json_succeed = msg => {
    return { $: 0, a: msg };
  };
  const _Json_fail = msg => {
    return { $: 1, a: msg };
  };
  const _Json_decodePrim = decoder => {
    return { $: 2, b: decoder };
  };
  var _Json_decodeInt = _Json_decodePrim(value =>
    typeof value !== "number"
      ? _Json_expecting("an INT", value)
      : -2147483647 < value && value < 2147483647 && (value | 0) === value
      ? elm$core$Result$Ok(value)
      : isFinite(value) && !(value % 1)
      ? elm$core$Result$Ok(value)
      : _Json_expecting("an INT", value)
  );
  var _Json_decodeBool = _Json_decodePrim(value =>
    typeof value === "boolean"
      ? elm$core$Result$Ok(value)
      : _Json_expecting("a BOOL", value)
  );
  var _Json_decodeFloat = _Json_decodePrim(value =>
    typeof value === "number"
      ? elm$core$Result$Ok(value)
      : _Json_expecting("a FLOAT", value)
  );
  var _Json_decodeValue = _Json_decodePrim(value =>
    elm$core$Result$Ok(_Json_wrap(value))
  );
  var _Json_decodeString = _Json_decodePrim(value =>
    typeof value === "string"
      ? elm$core$Result$Ok(value)
      : value instanceof String
      ? elm$core$Result$Ok(value + "")
      : _Json_expecting("a STRING", value)
  );
  const _Json_decodeList = decoder => {
    return { $: 3, b: decoder };
  };
  const _Json_decodeArray = decoder => {
    return { $: 4, b: decoder };
  };
  const _Json_decodeNull = value => {
    return { $: 5, c: value };
  };
  var _Json_decodeField = F2((field, decoder) => {
    return { $: 6, d: field, b: decoder };
  });
  var _Json_decodeIndex = F2((index, decoder) => {
    return { $: 7, e: index, b: decoder };
  });
  const _Json_decodeKeyValuePairs = decoder => {
    return { $: 8, b: decoder };
  };
  const _Json_mapMany = (f, decoders) => {
    return { $: 9, f: f, g: decoders };
  };
  var _Json_andThen = F2((callback, decoder) => {
    return { $: 10, b: decoder, h: callback };
  });
  const _Json_oneOf = decoders => {
    return { $: 11, g: decoders };
  };
  var _Json_map1 = F2((f, d1) => _Json_mapMany(f, [d1]));
  var _Json_map2 = F3((f, d1, d2) => _Json_mapMany(f, [d1, d2]));
  var _Json_map3 = F4((f, d1, d2, d3) => _Json_mapMany(f, [d1, d2, d3]));
  var _Json_map4 = F5((f, d1, d2, d3, d4) =>
    _Json_mapMany(f, [d1, d2, d3, d4])
  );
  var _Json_map5 = F6((f, d1, d2, d3, d4, d5) =>
    _Json_mapMany(f, [d1, d2, d3, d4, d5])
  );
  var _Json_map6 = F7((f, d1, d2, d3, d4, d5, d6) =>
    _Json_mapMany(f, [d1, d2, d3, d4, d5, d6])
  );
  var _Json_map7 = F8((f, d1, d2, d3, d4, d5, d6, d7) =>
    _Json_mapMany(f, [d1, d2, d3, d4, d5, d6, d7])
  );
  var _Json_map8 = F9((f, d1, d2, d3, d4, d5, d6, d7, d8) =>
    _Json_mapMany(f, [d1, d2, d3, d4, d5, d6, d7, d8])
  );
  var _Json_runOnString = F2((decoder, string) => {
    try {
      var value = JSON.parse(string);
      _Json_runHelp(decoder, value);
    } catch (e) {
      return elm$core$Result$Err(
        A2(
          elm$json$Json$Decode$Failure,
          "This is not valid JSON! " + e.message,
          _Json_wrap(string)
        )
      );
    }
  });
  var _Json_run = F2((decoder, value) =>
    _Json_runHelp(decoder, _Json_unwrap(value))
  );
  const _Json_runHelp = (decoder, value) => {
    switch (decoder.$) {
      case 2:
        decoder.b(value);
      case 5:
        return value === null
          ? elm$core$Result$Ok(decoder.c)
          : _Json_expecting("null", value);
      case 3:
        if (!_Json_isArray(value)) {
          return _Json_expecting("a LIST", value);
        }
        return _Json_runArrayDecoder(decoder.b, value, _List_fromArray);
      case 4:
        if (!_Json_isArray(value)) {
          return _Json_expecting("an ARRAY", value);
        }
        return _Json_runArrayDecoder(decoder.b, value, _Json_toElmArray);
      case 6:
        var field = decoder.d;
        if (typeof value !== "object" || value === null || !(field in value)) {
          return _Json_expecting(
            "an OBJECT with a field named `" + field + "`",
            value
          );
        }
        var result = _Json_runHelp(decoder.b, value[field]);
        return elm$core$Result$isOk(result)
          ? result
          : elm$core$Result$Err(
              A2(elm$json$Json$Decode$Field, field, result.a)
            );
      case 7:
        var index = decoder.e;
        if (!_Json_isArray(value)) {
          return _Json_expecting("an ARRAY", value);
        }
        if (index >= value.length) {
          return _Json_expecting(
            "a LONGER array. Need index " +
              index +
              " but only see " +
              value.length +
              " entries",
            value
          );
        }
        var result = _Json_runHelp(decoder.b, value[index]);
        return elm$core$Result$isOk(result)
          ? result
          : elm$core$Result$Err(
              A2(elm$json$Json$Decode$Index, index, result.a)
            );
      case 8:
        if (
          typeof value !== "object" ||
          value === null ||
          _Json_isArray(value)
        ) {
          return _Json_expecting("an OBJECT", value);
        }
        var keyValuePairs = _List_Nil;
        for (var key in value) {
          if (value.hasOwnProperty(key)) {
            var result = _Json_runHelp(decoder.b, value[key]);
            if (!elm$core$Result$isOk(result)) {
              return elm$core$Result$Err(
                A2(elm$json$Json$Decode$Field, key, result.a)
              );
            }
            keyValuePairs = _List_Cons(
              _Utils_Tuple2(key, result.a),
              keyValuePairs
            );
          }
        }
        return elm$core$Result$Ok(elm$core$List$reverse(keyValuePairs));
      case 9:
        var answer = decoder.f;
        var decoders = decoder.g;
        for (var i = 0; i < decoders.length; i++) {
          var result = _Json_runHelp(decoders[i], value);
          if (!elm$core$Result$isOk(result)) {
            return result;
          }
          answer = answer(result.a);
        }
        return elm$core$Result$Ok(answer);
      case 10:
        var result = _Json_runHelp(decoder.b, value);
        return !elm$core$Result$isOk(result)
          ? result
          : _Json_runHelp(decoder.h(result.a), value);
      case 11:
        var errors = _List_Nil;
        for (var temp = decoder.g; temp.b; temp = temp.b) {
          var result = _Json_runHelp(temp.a, value);
          if (elm$core$Result$isOk(result)) {
            return result;
          }
          errors = _List_Cons(result.a, errors);
        }
        return elm$core$Result$Err(
          elm$json$Json$Decode$OneOf(elm$core$List$reverse(errors))
        );
      case 1:
        return elm$core$Result$Err(
          A2(elm$json$Json$Decode$Failure, decoder.a, _Json_wrap(value))
        );
      case 0:
        return elm$core$Result$Ok(decoder.a);
    }
  };
  const _Json_runArrayDecoder = (decoder, value, toElmValue) => {
    var len = value.length;
    var array = new Array(len);
    for (var i = 0; i < len; i++) {
      var result = _Json_runHelp(decoder, value[i]);
      if (!elm$core$Result$isOk(result)) {
        return elm$core$Result$Err(A2(elm$json$Json$Decode$Index, i, result.a));
      }
      array[i] = result.a;
    }
    return elm$core$Result$Ok(toElmValue(array));
  };
  const _Json_isArray = value =>
    Array.isArray(value) ||
    (typeof FileList !== "undefined" && value instanceof FileList);
  const _Json_toElmArray = array =>
    A2(elm$core$Array$initialize, array.length, i => array[i]);
  const _Json_expecting = (type, value) =>
    elm$core$Result$Err(
      A2(elm$json$Json$Decode$Failure, "Expecting " + type, _Json_wrap(value))
    );
  const _Json_equality = (x, y) => {
    if (x === y) {
      return !0;
    }
    if (x.$ !== y.$) {
      return !1;
    }
    switch (x.$) {
      case 0:
      case 1:
        return x.a === y.a;
      case 2:
        return x.b === y.b;
      case 5:
        return x.c === y.c;
      case 3:
      case 4:
      case 8:
        return _Json_equality(x.b, y.b);
      case 6:
        return x.d === y.d && _Json_equality(x.b, y.b);
      case 7:
        return x.e === y.e && _Json_equality(x.b, y.b);
      case 9:
        return x.f === y.f && _Json_listEquality(x.g, y.g);
      case 10:
        return x.h === y.h && _Json_equality(x.b, y.b);
      case 11:
        return _Json_listEquality(x.g, y.g);
    }
  };
  const _Json_listEquality = (aDecoders, bDecoders) => {
    var len = aDecoders.length;
    if (len !== bDecoders.length) {
      return !1;
    }
    for (var i = 0; i < len; i++) {
      if (!_Json_equality(aDecoders[i], bDecoders[i])) {
        return !1;
      }
    }
    return !0;
  };
  var _Json_encode = F2(
    (indentLevel, value) =>
      JSON.stringify(_Json_unwrap(value), null, indentLevel) + ""
  );
  const _Json_wrap_UNUSED = value => {
    return { $: 0, a: value };
  };
  const _Json_unwrap_UNUSED = value => value.a;
  const _Json_wrap = value => value;
  const _Json_unwrap = value => value;
  const _Json_emptyArray = () => [];
  const _Json_emptyObject = () => {};
  var _Json_addField = F3((key, value, object) => {
    object[key] = _Json_unwrap(value);
    return object;
  });
  const _Json_addEntry = func =>
    F2((entry, array) => {
      array.push(_Json_unwrap(func(entry)));
      return array;
    });
  var _Json_encodeNull = _Json_wrap(null);
  const _Scheduler_succeed = value => {
    return { $: 0, a: value };
  };
  const _Scheduler_fail = error => {
    return { $: 1, a: error };
  };
  const _Scheduler_binding = callback => {
    return { $: 2, b: callback, c: null };
  };
  var _Scheduler_andThen = F2((callback, task) => {
    return { $: 3, b: callback, d: task };
  });
  var _Scheduler_onError = F2((callback, task) => {
    return { $: 4, b: callback, d: task };
  });
  const _Scheduler_receive = callback => {
    return { $: 5, b: callback };
  };
  var _Scheduler_guid = 0;
  const _Scheduler_rawSpawn = task => {
    var proc = { $: 0, e: _Scheduler_guid++, f: task, g: null, h: [] };
    _Scheduler_enqueue(proc);
    return proc;
  };
  const _Scheduler_spawn = task =>
    _Scheduler_binding(callback =>
      callback(_Scheduler_succeed(_Scheduler_rawSpawn(task)))
    );
  const _Scheduler_rawSend = (proc, msg) => {
    proc.h.push(msg);
    _Scheduler_enqueue(proc);
  };
  var _Scheduler_send = F2((proc, msg) =>
    _Scheduler_binding(callback => {
      _Scheduler_rawSend(proc, msg);
      callback(_Scheduler_succeed(_Utils_Tuple0));
    })
  );
  const _Scheduler_kill = proc =>
    _Scheduler_binding(callback => {
      var task = proc.f;
      if (task.$ === 2 && task.c) {
        task.c();
      }
      proc.f = null;
      callback(_Scheduler_succeed(_Utils_Tuple0));
    });
  var _Scheduler_working = !1;
  var _Scheduler_queue = [];
  const _Scheduler_enqueue = proc => {
    _Scheduler_queue.push(proc);
    if (_Scheduler_working) {
      return;
    }
    _Scheduler_working = !0;
    while ((proc = _Scheduler_queue.shift())) {
      _Scheduler_step(proc);
    }
    _Scheduler_working = !1;
  };
  const _Scheduler_step = proc => {
    while (proc.f) {
      var rootTag = proc.f.$;
      if (rootTag === 0 || rootTag === 1) {
        while (proc.g && proc.g.$ !== rootTag) {
          proc.g = proc.g.i;
        }
        if (!proc.g) {
          return;
        }
        proc.f = proc.g.b(proc.f.a);
        proc.g = proc.g.i;
      } else if (rootTag === 2) {
        proc.f.c = proc.f.b(newRoot => {
          proc.f = newRoot;
          _Scheduler_enqueue(proc);
        });
        return;
      } else if (rootTag === 5) {
        if (proc.h.length === 0) {
          return;
        }
        proc.f = proc.f.b(proc.h.shift());
      } else {
        proc.g = { $: rootTag === 3 ? 0 : 1, b: proc.f.b, i: proc.g };
        proc.f = proc.f.d;
      }
    }
  };
  const _Process_sleep = time =>
    _Scheduler_binding(callback => {
      var id = setTimeout(
        () => callback(_Scheduler_succeed(_Utils_Tuple0)),
        time
      );
      return () => clearTimeout(id);
    });
  var _Platform_worker = F4((impl, flagDecoder, debugMetadata, args) =>
    _Platform_initialize(
      flagDecoder,
      args,
      impl.a2,
      impl.bn,
      impl.bj,
      () => function() {}
    )
  );
  const _Platform_initialize = (
    flagDecoder,
    args,
    init,
    update,
    subscriptions,
    stepperBuilder
  ) => {
    var result = A2(
      _Json_run,
      flagDecoder,
      _Json_wrap(args ? args.flags : undefined)
    );
    elm$core$Result$isOk(result) || _Debug_crash(2);
    var managers = {};
    result = init(result.a);
    var model = result.a;
    var stepper = stepperBuilder(sendToApp, model);
    var ports = _Platform_setupEffects(managers, sendToApp);
    const sendToApp = (msg, viewMetadata) => {
      result = A2(update, msg, model);
      stepper((model = result.a), viewMetadata);
      _Platform_dispatchEffects(managers, result.b, subscriptions(model));
    };
    _Platform_dispatchEffects(managers, result.b, subscriptions(model));
    return ports ? { ports: ports } : {};
  };
  var _Platform_preload;
  const _Platform_registerPreload = url => _Platform_preload.add(url);
  var _Platform_effectManagers = {};
  const _Platform_setupEffects = (managers, sendToApp) => {
    var ports;
    for (var key in _Platform_effectManagers) {
      var manager = _Platform_effectManagers[key];
      if (manager.a) {
        ports = ports || {};
        ports[key] = manager.a(key, sendToApp);
      }
      managers[key] = _Platform_instantiateManager(manager, sendToApp);
    }
    return ports;
  };
  const _Platform_createManager = (
    init,
    onEffects,
    onSelfMsg,
    cmdMap,
    subMap
  ) => {
    return { b: init, c: onEffects, d: onSelfMsg, e: cmdMap, f: subMap };
  };
  const _Platform_instantiateManager = (info, sendToApp) => {
    var router = { g: sendToApp, h: undefined };
    var onEffects = info.c;
    var onSelfMsg = info.d;
    var cmdMap = info.e;
    var subMap = info.f;
    const loop = state =>
      A2(
        _Scheduler_andThen,
        loop,
        _Scheduler_receive(msg => {
          var value = msg.a;
          if (msg.$ === 0) {
            return A3(onSelfMsg, router, value, state);
          }
          return cmdMap && subMap
            ? A4(onEffects, router, value.i, value.j, state)
            : A3(onEffects, router, cmdMap ? value.i : value.j, state);
        })
      );
    return (router.h = _Scheduler_rawSpawn(
      A2(_Scheduler_andThen, loop, info.b)
    ));
  };
  var _Platform_sendToApp = F2((router, msg) =>
    _Scheduler_binding(callback => {
      router.g(msg);
      callback(_Scheduler_succeed(_Utils_Tuple0));
    })
  );
  var _Platform_sendToSelf = F2((router, msg) =>
    A2(_Scheduler_send, router.h, { $: 0, a: msg })
  );
  const _Platform_leaf = home => value => {
    return { $: 1, k: home, l: value };
  };
  const _Platform_batch = list => {
    return { $: 2, m: list };
  };
  var _Platform_map = F2((tagger, bag) => {
    return { $: 3, n: tagger, o: bag };
  });
  const _Platform_dispatchEffects = (managers, cmdBag, subBag) => {
    var effectsDict = {};
    _Platform_gatherEffects(!0, cmdBag, effectsDict, null);
    _Platform_gatherEffects(!1, subBag, effectsDict, null);
    for (var home in managers) {
      _Scheduler_rawSend(managers[home], {
        $: "fx",
        a: effectsDict[home] || { i: _List_Nil, j: _List_Nil }
      });
    }
  };
  const _Platform_gatherEffects = (isCmd, bag, effectsDict, taggers) => {
    switch (bag.$) {
      case 1:
        var home = bag.k;
        var effect = _Platform_toEffect(isCmd, home, taggers, bag.l);
        effectsDict[home] = _Platform_insert(isCmd, effect, effectsDict[home]);
        return;
      case 2:
        for (var list = bag.m; list.b; list = list.b) {
          _Platform_gatherEffects(isCmd, list.a, effectsDict, taggers);
        }
        return;
      case 3:
        _Platform_gatherEffects(isCmd, bag.o, effectsDict, {
          p: bag.n,
          q: taggers
        });
        return;
    }
  };
  const _Platform_toEffect = (isCmd, home, taggers, value) => {
    const applyTaggers = x => {
      for (var temp = taggers; temp; temp = temp.q) {
        x = temp.p(x);
      }
      return x;
    };
    var map = isCmd
      ? _Platform_effectManagers[home].e
      : _Platform_effectManagers[home].f;
    return A2(map, applyTaggers, value);
  };
  const _Platform_insert = (isCmd, newEffect, effects) => {
    effects = effects || { i: _List_Nil, j: _List_Nil };
    isCmd
      ? (effects.i = _List_Cons(newEffect, effects.i))
      : (effects.j = _List_Cons(newEffect, effects.j));
    return effects;
  };
  const _Platform_checkPortName = name => {
    if (_Platform_effectManagers[name]) {
      _Debug_crash(3, name);
    }
  };
  const _Platform_outgoingPort = (name, converter) => {
    _Platform_checkPortName(name);
    _Platform_effectManagers[name] = {
      e: _Platform_outgoingPortMap,
      r: converter,
      a: _Platform_setupOutgoingPort
    };
    return _Platform_leaf(name);
  };
  var _Platform_outgoingPortMap = F2((tagger, value) => value);
  const _Platform_setupOutgoingPort = name => {
    var subs = [];
    var converter = _Platform_effectManagers[name].r;
    var init = _Process_sleep(0);
    _Platform_effectManagers[name].b = init;
    _Platform_effectManagers[name].c = F3((router, cmdList, state) => {
      for (; cmdList.b; cmdList = cmdList.b) {
        var currentSubs = subs;
        var value = _Json_unwrap(converter(cmdList.a));
        for (var i = 0; i < currentSubs.length; i++) {
          currentSubs[i](value);
        }
      }
      return init;
    });
    const subscribe = callback => subs.push(callback);
    const unsubscribe = callback => {
      subs = subs.slice();
      var index = subs.indexOf(callback);
      if (index >= 0) {
        subs.splice(index, 1);
      }
    };
    return { subscribe: subscribe, unsubscribe: unsubscribe };
  };
  const _Platform_incomingPort = (name, converter) => {
    _Platform_checkPortName(name);
    _Platform_effectManagers[name] = {
      f: _Platform_incomingPortMap,
      r: converter,
      a: _Platform_setupIncomingPort
    };
    return _Platform_leaf(name);
  };
  var _Platform_incomingPortMap = F2((tagger, finalTagger) => value =>
    tagger(finalTagger(value))
  );
  const _Platform_setupIncomingPort = (name, sendToApp) => {
    var subs = _List_Nil;
    var converter = _Platform_effectManagers[name].r;
    var init = _Scheduler_succeed(null);
    _Platform_effectManagers[name].b = init;
    _Platform_effectManagers[name].c = F3((router, subList, state) => {
      subs = subList;
      return init;
    });
    const send = incomingValue => {
      var result = A2(_Json_run, converter, _Json_wrap(incomingValue));
      elm$core$Result$isOk(result) || _Debug_crash(4, name, result.a);
      var value = result.a;
      for (var temp = subs; temp.b; temp = temp.b) {
        sendToApp(temp.a(value));
      }
    };
    return { send: send };
  };
  const _Platform_export = exports =>
    scope.Elm
      ? _Platform_mergeExportsProd(scope.Elm, exports)
      : (scope.Elm = exports);
  const _Platform_mergeExportsProd = (obj, exports) => {
    for (var name in exports) {
      name in obj
        ? name == "init"
          ? _Debug_crash(6)
          : _Platform_mergeExportsProd(obj[name], exports[name])
        : (obj[name] = exports[name]);
    }
  };
  const _Platform_export_UNUSED = exports =>
    scope.Elm
      ? _Platform_mergeExportsDebug("Elm", scope.Elm, exports)
      : (scope.Elm = exports);
  const _Platform_mergeExportsDebug = (moduleName, obj, exports) => {
    for (var name in exports) {
      name in obj
        ? name == "init"
          ? _Debug_crash(6, moduleName)
          : _Platform_mergeExportsDebug(
              moduleName + "." + name,
              obj[name],
              exports[name]
            )
        : (obj[name] = exports[name]);
    }
  };
  var _VirtualDom_divertHrefToApp;
  var _VirtualDom_doc = typeof document !== "undefined" ? document : {};
  const _VirtualDom_appendChild = (parent, child) => parent.appendChild(child);
  var _VirtualDom_init = F4((virtualNode, flagDecoder, debugMetadata, args) => {
    var node = args.node;
    node.parentNode.replaceChild(
      _VirtualDom_render(virtualNode, function() {}),
      node
    );
    return {};
  });
  const _VirtualDom_text = string => {
    return { $: 0, a: string };
  };
  var _VirtualDom_nodeNS = F2((namespace, tag) =>
    F2((factList, kidList) => {
      for (
        var kids = [], descendantsCount = 0;
        kidList.b;
        kidList = kidList.b
      ) {
        var kid = kidList.a;
        descendantsCount += kid.b || 0;
        kids.push(kid);
      }
      descendantsCount += kids.length;
      return {
        $: 1,
        c: tag,
        d: _VirtualDom_organizeFacts(factList),
        e: kids,
        f: namespace,
        b: descendantsCount
      };
    })
  );
  var _VirtualDom_node = _VirtualDom_nodeNS(undefined);
  var _VirtualDom_keyedNodeNS = F2((namespace, tag) =>
    F2((factList, kidList) => {
      for (
        var kids = [], descendantsCount = 0;
        kidList.b;
        kidList = kidList.b
      ) {
        var kid = kidList.a;
        descendantsCount += kid.b.b || 0;
        kids.push(kid);
      }
      descendantsCount += kids.length;
      return {
        $: 2,
        c: tag,
        d: _VirtualDom_organizeFacts(factList),
        e: kids,
        f: namespace,
        b: descendantsCount
      };
    })
  );
  var _VirtualDom_keyedNode = _VirtualDom_keyedNodeNS(undefined);
  const _VirtualDom_custom = (factList, model, render, diff) => {
    return {
      $: 3,
      d: _VirtualDom_organizeFacts(factList),
      g: model,
      h: render,
      i: diff
    };
  };
  var _VirtualDom_map = F2((tagger, node) => {
    return { $: 4, j: tagger, k: node, b: 1 + (node.b || 0) };
  });
  const _VirtualDom_thunk = (refs, thunk) => {
    return { $: 5, l: refs, m: thunk, k: undefined };
  };
  var _VirtualDom_lazy = F2((func, a) =>
    _VirtualDom_thunk([func, a], () => func(a))
  );
  var _VirtualDom_lazy2 = F3((func, a, b) =>
    _VirtualDom_thunk([func, a, b], () => A2(func, a, b))
  );
  var _VirtualDom_lazy3 = F4((func, a, b, c) =>
    _VirtualDom_thunk([func, a, b, c], () => A3(func, a, b, c))
  );
  var _VirtualDom_lazy4 = F5((func, a, b, c, d) =>
    _VirtualDom_thunk([func, a, b, c, d], () => A4(func, a, b, c, d))
  );
  var _VirtualDom_lazy5 = F6((func, a, b, c, d, e) =>
    _VirtualDom_thunk([func, a, b, c, d, e], () => A5(func, a, b, c, d, e))
  );
  var _VirtualDom_lazy6 = F7((func, a, b, c, d, e, f) =>
    _VirtualDom_thunk([func, a, b, c, d, e, f], () =>
      A6(func, a, b, c, d, e, f)
    )
  );
  var _VirtualDom_lazy7 = F8((func, a, b, c, d, e, f, g) =>
    _VirtualDom_thunk([func, a, b, c, d, e, f, g], () =>
      A7(func, a, b, c, d, e, f, g)
    )
  );
  var _VirtualDom_lazy8 = F9((func, a, b, c, d, e, f, g, h) =>
    _VirtualDom_thunk([func, a, b, c, d, e, f, g, h], () =>
      A8(func, a, b, c, d, e, f, g, h)
    )
  );
  var _VirtualDom_on = F2((key, handler) => {
    return { $: "a0", n: key, o: handler };
  });
  var _VirtualDom_style = F2((key, value) => {
    return { $: "a1", n: key, o: value };
  });
  var _VirtualDom_property = F2((key, value) => {
    return { $: "a2", n: key, o: value };
  });
  var _VirtualDom_attribute = F2((key, value) => {
    return { $: "a3", n: key, o: value };
  });
  var _VirtualDom_attributeNS = F3((namespace, key, value) => {
    return { $: "a4", n: key, o: { f: namespace, o: value } };
  });
  const _VirtualDom_noScript = tag => (tag == "script" ? "p" : tag);
  const _VirtualDom_noOnOrFormAction = key =>
    /^(on|formAction$)/i.test(key) ? "data-" + key : key;
  const _VirtualDom_noInnerHtmlOrFormAction = key =>
    key == "innerHTML" || key == "formAction" ? "data-" + key : key;
  const _VirtualDom_noJavaScriptUri = value =>
    /^javascript:/i.test(value.replace(/\s/g, "")) ? "" : value;
  const _VirtualDom_noJavaScriptUri_UNUSED = value =>
    /^javascript:/i.test(value.replace(/\s/g, ""))
      ? 'javascript:alert("This is an XSS vector. Please use ports or web components instead.")'
      : value;
  const _VirtualDom_noJavaScriptOrHtmlUri = value =>
    /^\s*(javascript:|data:text\/html)/i.test(value) ? "" : value;
  const _VirtualDom_noJavaScriptOrHtmlUri_UNUSED = value =>
    /^\s*(javascript:|data:text\/html)/i.test(value)
      ? 'javascript:alert("This is an XSS vector. Please use ports or web components instead.")'
      : value;
  var _VirtualDom_mapAttribute = F2((func, attr) =>
    attr.$ === "a0"
      ? A2(_VirtualDom_on, attr.n, _VirtualDom_mapHandler(func, attr.o))
      : attr
  );
  const _VirtualDom_mapHandler = (func, handler) => {
    var tag = elm$virtual_dom$VirtualDom$toHandlerInt(handler);
    return {
      $: handler.$,
      a: !tag
        ? A2(elm$json$Json$Decode$map, func, handler.a)
        : A3(
            elm$json$Json$Decode$map2,
            tag < 3 ? _VirtualDom_mapEventTuple : _VirtualDom_mapEventRecord,
            elm$json$Json$Decode$succeed(func),
            handler.a
          )
    };
  };
  var _VirtualDom_mapEventTuple = F2((func, tuple) =>
    _Utils_Tuple2(func(tuple.a), tuple.b)
  );
  var _VirtualDom_mapEventRecord = F2((func, record) => {
    return { r: func(record.r), aa: record.aa, Z: record.Z };
  });
  const _VirtualDom_organizeFacts = factList => {
    for (var facts = {}; factList.b; factList = factList.b) {
      var entry = factList.a;
      var tag = entry.$;
      var key = entry.n;
      var value = entry.o;
      if (tag === "a2") {
        key === "className"
          ? _VirtualDom_addClass(facts, key, _Json_unwrap(value))
          : (facts[key] = _Json_unwrap(value));
        continue;
      }
      var subFacts = facts[tag] || (facts[tag] = {});
      tag === "a3" && key === "class"
        ? _VirtualDom_addClass(subFacts, key, value)
        : (subFacts[key] = value);
    }
    return facts;
  };
  const _VirtualDom_addClass = (object, key, newClass) => {
    var classes = object[key];
    object[key] = classes ? classes + " " + newClass : newClass;
  };
  const _VirtualDom_render = (vNode, eventNode) => {
    var tag = vNode.$;
    if (tag === 5) {
      return _VirtualDom_render(vNode.k || (vNode.k = vNode.m()), eventNode);
    }
    if (tag === 0) {
      return _VirtualDom_doc.createTextNode(vNode.a);
    }
    if (tag === 4) {
      var subNode = vNode.k;
      var tagger = vNode.j;
      while (subNode.$ === 4) {
        typeof tagger !== "object"
          ? (tagger = [tagger, subNode.j])
          : tagger.push(subNode.j);
        subNode = subNode.k;
      }
      var subEventRoot = { j: tagger, p: eventNode };
      var domNode = _VirtualDom_render(subNode, subEventRoot);
      domNode.elm_event_node_ref = subEventRoot;
      return domNode;
    }
    if (tag === 3) {
      var domNode = vNode.h(vNode.g);
      _VirtualDom_applyFacts(domNode, eventNode, vNode.d);
      return domNode;
    }
    var domNode = vNode.f
      ? _VirtualDom_doc.createElementNS(vNode.f, vNode.c)
      : _VirtualDom_doc.createElement(vNode.c);
    if (_VirtualDom_divertHrefToApp && vNode.c == "a") {
      domNode.addEventListener("click", _VirtualDom_divertHrefToApp(domNode));
    }
    _VirtualDom_applyFacts(domNode, eventNode, vNode.d);
    for (var kids = vNode.e, i = 0; i < kids.length; i++) {
      _VirtualDom_appendChild(
        domNode,
        _VirtualDom_render(tag === 1 ? kids[i] : kids[i].b, eventNode)
      );
    }
    return domNode;
  };
  const _VirtualDom_applyFacts = (domNode, eventNode, facts) => {
    for (var key in facts) {
      var value = facts[key];
      key === "a1"
        ? _VirtualDom_applyStyles(domNode, value)
        : key === "a0"
        ? _VirtualDom_applyEvents(domNode, eventNode, value)
        : key === "a3"
        ? _VirtualDom_applyAttrs(domNode, value)
        : key === "a4"
        ? _VirtualDom_applyAttrsNS(domNode, value)
        : ((key !== "value" && key !== "checked") || domNode[key] !== value) &&
          (domNode[key] = value);
    }
  };
  const _VirtualDom_applyStyles = (domNode, styles) => {
    var domNodeStyle = domNode.style;
    for (var key in styles) {
      domNodeStyle[key] = styles[key];
    }
  };
  const _VirtualDom_applyAttrs = (domNode, attrs) => {
    for (var key in attrs) {
      var value = attrs[key];
      typeof value !== "undefined"
        ? domNode.setAttribute(key, value)
        : domNode.removeAttribute(key);
    }
  };
  const _VirtualDom_applyAttrsNS = (domNode, nsAttrs) => {
    for (var key in nsAttrs) {
      var pair = nsAttrs[key];
      var namespace = pair.f;
      var value = pair.o;
      typeof value !== "undefined"
        ? domNode.setAttributeNS(namespace, key, value)
        : domNode.removeAttributeNS(namespace, key);
    }
  };
  const _VirtualDom_applyEvents = (domNode, eventNode, events) => {
    var allCallbacks = domNode.elmFs || (domNode.elmFs = {});
    for (var key in events) {
      var newHandler = events[key];
      var oldCallback = allCallbacks[key];
      if (!newHandler) {
        domNode.removeEventListener(key, oldCallback);
        allCallbacks[key] = undefined;
        continue;
      }
      if (oldCallback) {
        var oldHandler = oldCallback.q;
        if (oldHandler.$ === newHandler.$) {
          oldCallback.q = newHandler;
          continue;
        }
        domNode.removeEventListener(key, oldCallback);
      }
      oldCallback = _VirtualDom_makeCallback(eventNode, newHandler);
      domNode.addEventListener(
        key,
        oldCallback,
        _VirtualDom_passiveSupported && {
          passive: elm$virtual_dom$VirtualDom$toHandlerInt(newHandler) < 2
        }
      );
      allCallbacks[key] = oldCallback;
    }
  };
  var _VirtualDom_passiveSupported;
  try {
    window.addEventListener(
      "t",
      null,
      Object.defineProperty({}, "passive", {
        get: () => (_VirtualDom_passiveSupported = !0)
      })
    );
  } catch (e) {}
  const _VirtualDom_makeCallback = (eventNode, initialHandler) => {
    const callback = event => {
      var handler = callback.q;
      var result = _Json_runHelp(handler.a, event);
      if (!elm$core$Result$isOk(result)) {
        return;
      }
      var tag = elm$virtual_dom$VirtualDom$toHandlerInt(handler);
      var value = result.a;
      var message = !tag ? value : tag < 3 ? value.a : value.r;
      var stopPropagation = tag == 1 ? value.b : tag == 3 && value.aa;
      var currentEventNode =
        (stopPropagation && event.stopPropagation(),
        (tag == 2 ? value.b : tag == 3 && value.Z) && event.preventDefault(),
        eventNode);
      var tagger;
      var i;
      while ((tagger = currentEventNode.j)) {
        if (typeof tagger == "function") {
          message = tagger(message);
        } else {
          for (var i = tagger.length; i--; ) {
            message = tagger[i](message);
          }
        }
        currentEventNode = currentEventNode.p;
      }
      currentEventNode(message, stopPropagation);
    };
    callback.q = initialHandler;
    return callback;
  };
  const _VirtualDom_equalEvents = (x, y) =>
    x.$ == y.$ && _Json_equality(x.a, y.a);
  const _VirtualDom_diff = (x, y) => {
    var patches = [];
    _VirtualDom_diffHelp(x, y, patches, 0);
    return patches;
  };
  const _VirtualDom_pushPatch = (patches, type, index, data) => {
    var patch = { $: type, r: index, s: data, t: undefined, u: undefined };
    patches.push(patch);
    return patch;
  };
  const _VirtualDom_diffHelp = (x, y, patches, index) => {
    if (x === y) {
      return;
    }
    var xType = x.$;
    var yType = y.$;
    if (xType !== yType) {
      if (xType === 1 && yType === 2) {
        y = _VirtualDom_dekey(y);
        yType = 1;
      } else {
        _VirtualDom_pushPatch(patches, 0, index, y);
        return;
      }
    }
    switch (yType) {
      case 5:
        var xRefs = x.l;
        var yRefs = y.l;
        var i = xRefs.length;
        var same = i === yRefs.length;
        while (same && i--) {
          same = xRefs[i] === yRefs[i];
        }
        if (same) {
          y.k = x.k;
          return;
        }
        y.k = y.m();
        var subPatches = [];
        _VirtualDom_diffHelp(x.k, y.k, subPatches, 0);
        subPatches.length > 0 &&
          _VirtualDom_pushPatch(patches, 1, index, subPatches);
        return;
      case 4:
        var xTaggers = x.j;
        var yTaggers = y.j;
        var nesting = !1;
        var xSubNode = x.k;
        while (xSubNode.$ === 4) {
          nesting = !0;
          typeof xTaggers !== "object"
            ? (xTaggers = [xTaggers, xSubNode.j])
            : xTaggers.push(xSubNode.j);
          xSubNode = xSubNode.k;
        }
        var ySubNode = y.k;
        while (ySubNode.$ === 4) {
          nesting = !0;
          typeof yTaggers !== "object"
            ? (yTaggers = [yTaggers, ySubNode.j])
            : yTaggers.push(ySubNode.j);
          ySubNode = ySubNode.k;
        }
        if (nesting && xTaggers.length !== yTaggers.length) {
          _VirtualDom_pushPatch(patches, 0, index, y);
          return;
        }
        if (
          nesting
            ? !_VirtualDom_pairwiseRefEqual(xTaggers, yTaggers)
            : xTaggers !== yTaggers
        ) {
          _VirtualDom_pushPatch(patches, 2, index, yTaggers);
        }
        _VirtualDom_diffHelp(xSubNode, ySubNode, patches, index + 1);
        return;
      case 0:
        if (x.a !== y.a) {
          _VirtualDom_pushPatch(patches, 3, index, y.a);
        }
        return;
      case 1:
        _VirtualDom_diffNodes(x, y, patches, index, _VirtualDom_diffKids);
        return;
      case 2:
        _VirtualDom_diffNodes(x, y, patches, index, _VirtualDom_diffKeyedKids);
        return;
      case 3:
        if (x.h !== y.h) {
          _VirtualDom_pushPatch(patches, 0, index, y);
          return;
        }
        var factsDiff = _VirtualDom_diffFacts(x.d, y.d);
        factsDiff && _VirtualDom_pushPatch(patches, 4, index, factsDiff);
        var patch = y.i(x.g, y.g);
        patch && _VirtualDom_pushPatch(patches, 5, index, patch);
        return;
    }
  };
  const _VirtualDom_pairwiseRefEqual = (as, bs) => {
    for (var i = 0; i < as.length; i++) {
      if (as[i] !== bs[i]) {
        return !1;
      }
    }
    return !0;
  };
  const _VirtualDom_diffNodes = (x, y, patches, index, diffKids) => {
    if (x.c !== y.c || x.f !== y.f) {
      _VirtualDom_pushPatch(patches, 0, index, y);
      return;
    }
    var factsDiff = _VirtualDom_diffFacts(x.d, y.d);
    factsDiff && _VirtualDom_pushPatch(patches, 4, index, factsDiff);
    diffKids(x, y, patches, index);
  };
  const _VirtualDom_diffFacts = (x, y, category) => {
    var diff;
    for (var xKey in x) {
      if (xKey === "a1" || xKey === "a0" || xKey === "a3" || xKey === "a4") {
        var subDiff = _VirtualDom_diffFacts(x[xKey], y[xKey] || {}, xKey);
        if (subDiff) {
          diff = diff || {};
          diff[xKey] = subDiff;
        }
        continue;
      }
      if (!(xKey in y)) {
        diff = diff || {};
        diff[xKey] = !category
          ? typeof x[xKey] === "string"
            ? ""
            : null
          : category === "a1"
          ? ""
          : category === "a0" || category === "a3"
          ? undefined
          : { f: x[xKey].f, o: undefined };
        continue;
      }
      var xValue = x[xKey];
      var yValue = y[xKey];
      if (
        (xValue === yValue && xKey !== "value" && xKey !== "checked") ||
        (category === "a0" && _VirtualDom_equalEvents(xValue, yValue))
      ) {
        continue;
      }
      diff = diff || {};
      diff[xKey] = yValue;
    }
    for (var yKey in y) {
      if (!(yKey in x)) {
        diff = diff || {};
        diff[yKey] = y[yKey];
      }
    }
    return diff;
  };
  const _VirtualDom_diffKids = (xParent, yParent, patches, index) => {
    var xKids = xParent.e;
    var yKids = yParent.e;
    var xLen = xKids.length;
    var yLen = yKids.length;
    if (xLen > yLen) {
      _VirtualDom_pushPatch(patches, 6, index, { v: yLen, i: xLen - yLen });
    } else if (xLen < yLen) {
      _VirtualDom_pushPatch(patches, 7, index, { v: xLen, e: yKids });
    }
    for (var minLen = xLen < yLen ? xLen : yLen, i = 0; i < minLen; i++) {
      var xKid = xKids[i];
      _VirtualDom_diffHelp(xKid, yKids[i], patches, ++index);
      index += xKid.b || 0;
    }
  };
  const _VirtualDom_diffKeyedKids = (xParent, yParent, patches, rootIndex) => {
    var localPatches = [];
    var changes = {};
    var inserts = [];
    var xKids = xParent.e;
    var yKids = yParent.e;
    var xLen = xKids.length;
    var yLen = yKids.length;
    var xIndex = 0;
    var yIndex = 0;
    var index = rootIndex;
    while (xIndex < xLen && yIndex < yLen) {
      var x = xKids[xIndex];
      var y = yKids[yIndex];
      var xKey = x.a;
      var yKey = y.a;
      var xNode = x.b;
      var yNode = y.b;
      var newMatch = undefined;
      var oldMatch = undefined;
      if (xKey === yKey) {
        index++;
        _VirtualDom_diffHelp(xNode, yNode, localPatches, index);
        index += xNode.b || 0;
        xIndex++;
        yIndex++;
        continue;
      }
      var xNext = xKids[xIndex + 1];
      var yNext = yKids[yIndex + 1];
      if (xNext) {
        var xNextKey = xNext.a;
        var xNextNode = xNext.b;
        oldMatch = yKey === xNextKey;
      }
      if (yNext) {
        var yNextKey = yNext.a;
        var yNextNode = yNext.b;
        newMatch = xKey === yNextKey;
      }
      if (newMatch && oldMatch) {
        index++;
        _VirtualDom_diffHelp(xNode, yNextNode, localPatches, index);
        _VirtualDom_insertNode(
          changes,
          localPatches,
          xKey,
          yNode,
          yIndex,
          inserts
        );
        index += xNode.b || 0;
        index++;
        _VirtualDom_removeNode(changes, localPatches, xKey, xNextNode, index);
        index += xNextNode.b || 0;
        xIndex += 2;
        yIndex += 2;
        continue;
      }
      if (newMatch) {
        index++;
        _VirtualDom_insertNode(
          changes,
          localPatches,
          yKey,
          yNode,
          yIndex,
          inserts
        );
        _VirtualDom_diffHelp(xNode, yNextNode, localPatches, index);
        index += xNode.b || 0;
        xIndex += 1;
        yIndex += 2;
        continue;
      }
      if (oldMatch) {
        index++;
        _VirtualDom_removeNode(changes, localPatches, xKey, xNode, index);
        index += xNode.b || 0;
        index++;
        _VirtualDom_diffHelp(xNextNode, yNode, localPatches, index);
        index += xNextNode.b || 0;
        xIndex += 2;
        yIndex += 1;
        continue;
      }
      if (xNext && xNextKey === yNextKey) {
        index++;
        _VirtualDom_removeNode(changes, localPatches, xKey, xNode, index);
        _VirtualDom_insertNode(
          changes,
          localPatches,
          yKey,
          yNode,
          yIndex,
          inserts
        );
        index += xNode.b || 0;
        index++;
        _VirtualDom_diffHelp(xNextNode, yNextNode, localPatches, index);
        index += xNextNode.b || 0;
        xIndex += 2;
        yIndex += 2;
        continue;
      }
      break;
    }
    while (xIndex < xLen) {
      index++;
      var x = xKids[xIndex];
      var xNode = x.b;
      _VirtualDom_removeNode(changes, localPatches, x.a, xNode, index);
      index += xNode.b || 0;
      xIndex++;
    }
    while (yIndex < yLen) {
      var endInserts = endInserts || [];
      var y = yKids[yIndex];
      _VirtualDom_insertNode(
        changes,
        localPatches,
        y.a,
        y.b,
        undefined,
        endInserts
      );
      yIndex++;
    }
    if (localPatches.length > 0 || inserts.length > 0 || endInserts) {
      _VirtualDom_pushPatch(patches, 8, rootIndex, {
        w: localPatches,
        x: inserts,
        y: endInserts
      });
    }
  };
  var _VirtualDom_POSTFIX = "_elmW6BL";
  const _VirtualDom_insertNode = (
    changes,
    localPatches,
    key,
    vnode,
    yIndex,
    inserts
  ) => {
    var entry = changes[key];
    if (!entry) {
      entry = { c: 0, z: vnode, r: yIndex, s: undefined };
      inserts.push({ r: yIndex, A: entry });
      changes[key] = entry;
      return;
    }
    if (entry.c === 1) {
      inserts.push({ r: yIndex, A: entry });
      entry.c = 2;
      var subPatches = [];
      _VirtualDom_diffHelp(entry.z, vnode, subPatches, entry.r);
      entry.r = yIndex;
      entry.s.s = { w: subPatches, A: entry };
      return;
    }
    _VirtualDom_insertNode(
      changes,
      localPatches,
      key + _VirtualDom_POSTFIX,
      vnode,
      yIndex,
      inserts
    );
  };
  const _VirtualDom_removeNode = (changes, localPatches, key, vnode, index) => {
    var entry = changes[key];
    if (!entry) {
      var patch = _VirtualDom_pushPatch(localPatches, 9, index, undefined);
      changes[key] = { c: 1, z: vnode, r: index, s: patch };
      return;
    }
    if (entry.c === 0) {
      entry.c = 2;
      var subPatches = [];
      _VirtualDom_diffHelp(vnode, entry.z, subPatches, index);
      _VirtualDom_pushPatch(localPatches, 9, index, {
        w: subPatches,
        A: entry
      });
      return;
    }
    _VirtualDom_removeNode(
      changes,
      localPatches,
      key + _VirtualDom_POSTFIX,
      vnode,
      index
    );
  };
  const _VirtualDom_addDomNodes = (domNode, vNode, patches, eventNode) =>
    _VirtualDom_addDomNodesHelp(
      domNode,
      vNode,
      patches,
      0,
      0,
      vNode.b,
      eventNode
    );
  const _VirtualDom_addDomNodesHelp = (
    domNode,
    vNode,
    patches,
    i,
    low,
    high,
    eventNode
  ) => {
    var patch = patches[i];
    var index = patch.r;
    while (index === low) {
      var patchType = patch.$;
      if (patchType === 1) {
        _VirtualDom_addDomNodes(domNode, vNode.k, patch.s, eventNode);
      } else if (patchType === 8) {
        patch.t = domNode;
        patch.u = eventNode;
        var subPatches = patch.s.w;
        if (subPatches.length > 0) {
          _VirtualDom_addDomNodesHelp(
            domNode,
            vNode,
            subPatches,
            0,
            low,
            high,
            eventNode
          );
        }
      } else if (patchType === 9) {
        patch.t = domNode;
        patch.u = eventNode;
        var data = patch.s;
        if (data) {
          data.A.s = domNode;
          var subPatches = data.w;
          if (subPatches.length > 0) {
            _VirtualDom_addDomNodesHelp(
              domNode,
              vNode,
              subPatches,
              0,
              low,
              high,
              eventNode
            );
          }
        }
      } else {
        patch.t = domNode;
        patch.u = eventNode;
      }
      i++;
      if (!(patch = patches[i]) || (index = patch.r) > high) {
        return i;
      }
    }
    var tag = vNode.$;
    if (tag === 4) {
      var subNode = vNode.k;
      while (subNode.$ === 4) {
        subNode = subNode.k;
      }
      return _VirtualDom_addDomNodesHelp(
        domNode,
        subNode,
        patches,
        i,
        low + 1,
        high,
        domNode.elm_event_node_ref
      );
    }
    var vKids = vNode.e;
    var childNodes = domNode.childNodes;
    for (var j = 0; j < vKids.length; j++) {
      low++;
      var vKid = tag === 1 ? vKids[j] : vKids[j].b;
      var nextLow = low + (vKid.b || 0);
      if (low <= index && index <= nextLow) {
        i = _VirtualDom_addDomNodesHelp(
          childNodes[j],
          vKid,
          patches,
          i,
          low,
          nextLow,
          eventNode
        );
        if (!(patch = patches[i]) || (index = patch.r) > high) {
          return i;
        }
      }
      low = nextLow;
    }
    return i;
  };
  const _VirtualDom_applyPatches = (
    rootDomNode,
    oldVirtualNode,
    patches,
    eventNode
  ) => {
    if (patches.length === 0) {
      return rootDomNode;
    }
    _VirtualDom_addDomNodes(rootDomNode, oldVirtualNode, patches, eventNode);
    return _VirtualDom_applyPatchesHelp(rootDomNode, patches);
  };
  const _VirtualDom_applyPatchesHelp = (rootDomNode, patches) => {
    for (var i = 0; i < patches.length; i++) {
      var patch = patches[i];
      var localDomNode = patch.t;
      var newNode = _VirtualDom_applyPatch(localDomNode, patch);
      if (localDomNode === rootDomNode) {
        rootDomNode = newNode;
      }
    }
    return rootDomNode;
  };
  const _VirtualDom_applyPatch = (domNode, patch) => {
    switch (patch.$) {
      case 0:
        _VirtualDom_applyPatchRedraw(domNode, patch.s, patch.u);
      case 4:
        _VirtualDom_applyFacts(domNode, patch.u, patch.s);
        return domNode;
      case 3:
        domNode.replaceData(0, domNode.length, patch.s);
        return domNode;
      case 1:
        return _VirtualDom_applyPatchesHelp(domNode, patch.s);
      case 2:
        if (domNode.elm_event_node_ref) {
          domNode.elm_event_node_ref.j = patch.s;
        } else {
          domNode.elm_event_node_ref = { j: patch.s, p: patch.u };
        }
        return domNode;
      case 6:
        var data = patch.s;
        for (var i = 0; i < data.i; i++) {
          domNode.removeChild(domNode.childNodes[data.v]);
        }
        return domNode;
      case 7:
        var data = patch.s;
        var kids = data.e;
        var i = data.v;
        var theEnd = domNode.childNodes[i];
        for (; i < kids.length; i++) {
          domNode.insertBefore(_VirtualDom_render(kids[i], patch.u), theEnd);
        }
        return domNode;
      case 9:
        var data = patch.s;
        if (!data) {
          domNode.parentNode.removeChild(domNode);
          return domNode;
        }
        var entry = data.A;
        if (typeof entry.r !== "undefined") {
          domNode.parentNode.removeChild(domNode);
        }
        entry.s = _VirtualDom_applyPatchesHelp(domNode, data.w);
        return domNode;
      case 8:
        return _VirtualDom_applyPatchReorder(domNode, patch);
      case 5:
        return patch.s(domNode);
      default:
        _Debug_crash(10);
    }
  };
  const _VirtualDom_applyPatchRedraw = (domNode, vNode, eventNode) => {
    var parentNode = domNode.parentNode;
    var newNode = _VirtualDom_render(vNode, eventNode);
    if (!newNode.elm_event_node_ref) {
      newNode.elm_event_node_ref = domNode.elm_event_node_ref;
    }
    if (parentNode && newNode !== domNode) {
      parentNode.replaceChild(newNode, domNode);
    }
    return newNode;
  };
  const _VirtualDom_applyPatchReorder = (domNode, patch) => {
    var data = patch.s;
    var frag = _VirtualDom_applyPatchReorderEndInsertsHelp(data.y, patch);
    domNode = _VirtualDom_applyPatchesHelp(domNode, data.w);
    var inserts = data.x;
    for (var i = 0; i < inserts.length; i++) {
      var insert = inserts[i];
      var entry = insert.A;
      var node = entry.c === 2 ? entry.s : _VirtualDom_render(entry.z, patch.u);
      domNode.insertBefore(node, domNode.childNodes[insert.r]);
    }
    if (frag) {
      _VirtualDom_appendChild(domNode, frag);
    }
    return domNode;
  };
  const _VirtualDom_applyPatchReorderEndInsertsHelp = (endInserts, patch) => {
    if (!endInserts) {
      return;
    }
    var frag = _VirtualDom_doc.createDocumentFragment();
    for (var i = 0; i < endInserts.length; i++) {
      var insert = endInserts[i];
      var entry = insert.A;
      _VirtualDom_appendChild(
        frag,
        entry.c === 2 ? entry.s : _VirtualDom_render(entry.z, patch.u)
      );
    }
    return frag;
  };
  const _VirtualDom_virtualize = node => {
    if (node.nodeType === 3) {
      return _VirtualDom_text(node.textContent);
    }
    if (node.nodeType !== 1) {
      return _VirtualDom_text("");
    }
    var attrList = _List_Nil;
    var attrs = node.attributes;
    for (var i = attrs.length; i--; ) {
      var attr = attrs[i];
      var name = attr.name;
      var value = attr.value;
      attrList = _List_Cons(A2(_VirtualDom_attribute, name, value), attrList);
    }
    var tag = node.tagName.toLowerCase();
    var kidList = _List_Nil;
    var kids = node.childNodes;
    for (var i = kids.length; i--; ) {
      kidList = _List_Cons(_VirtualDom_virtualize(kids[i]), kidList);
    }
    return A3(_VirtualDom_node, tag, attrList, kidList);
  };
  const _VirtualDom_dekey = keyedNode => {
    var keyedKids = keyedNode.e;
    var len = keyedKids.length;
    var kids = new Array(len);
    for (var i = 0; i < len; i++) {
      kids[i] = keyedKids[i].b;
    }
    return {
      $: 1,
      c: keyedNode.c,
      d: keyedNode.d,
      e: kids,
      f: keyedNode.f,
      b: keyedNode.b
    };
  };
  var _Debugger_element;
  var _Browser_element =
    _Debugger_element ||
    F4((impl, flagDecoder, debugMetadata, args) =>
      _Platform_initialize(
        flagDecoder,
        args,
        impl.a2,
        impl.bn,
        impl.bj,
        (sendToApp, initialModel) => {
          var view = impl.bp;
          var domNode = args.node;
          var currNode = _VirtualDom_virtualize(domNode);
          return _Browser_makeAnimator(initialModel, model => {
            var nextNode = view(model);
            var patches = _VirtualDom_diff(currNode, nextNode);
            domNode = _VirtualDom_applyPatches(
              domNode,
              currNode,
              patches,
              sendToApp
            );
            currNode = nextNode;
          });
        }
      )
    );
  var _Debugger_document;
  var _Browser_document =
    _Debugger_document ||
    F4((impl, flagDecoder, debugMetadata, args) =>
      _Platform_initialize(
        flagDecoder,
        args,
        impl.a2,
        impl.bn,
        impl.bj,
        (sendToApp, initialModel) => {
          var divertHrefToApp = impl.J && impl.J(sendToApp);
          var view = impl.bp;
          var title = _VirtualDom_doc.title;
          var bodyNode = _VirtualDom_doc.body;
          var currNode = _VirtualDom_virtualize(bodyNode);
          return _Browser_makeAnimator(initialModel, model => {
            _VirtualDom_divertHrefToApp = divertHrefToApp;
            var doc = view(model);
            var nextNode = _VirtualDom_node("body")(_List_Nil)(doc.aQ);
            var patches = _VirtualDom_diff(currNode, nextNode);
            bodyNode = _VirtualDom_applyPatches(
              bodyNode,
              currNode,
              patches,
              sendToApp
            );
            currNode = nextNode;
            _VirtualDom_divertHrefToApp = 0;
            title !== doc.bm && (_VirtualDom_doc.title = title = doc.bm);
          });
        }
      )
    );
  var _Browser_cancelAnimationFrame =
    typeof cancelAnimationFrame !== "undefined"
      ? cancelAnimationFrame
      : id => clearTimeout(id);
  var _Browser_requestAnimationFrame =
    typeof requestAnimationFrame !== "undefined"
      ? requestAnimationFrame
      : callback => setTimeout(callback, 1000 / 60);
  const _Browser_makeAnimator = (model, draw) => {
    draw(model);
    var state = 0;
    const updateIfNeeded = () =>
      (state =
        state === 1
          ? 0
          : (_Browser_requestAnimationFrame(updateIfNeeded), draw(model), 1));
    return (nextModel, isSync) => {
      model = nextModel;
      isSync
        ? (draw(model), state === 2 && (state = 1))
        : (state === 0 && _Browser_requestAnimationFrame(updateIfNeeded),
          (state = 2));
    };
  };
  const _Browser_application = impl => {
    var onUrlChange = impl.bd;
    var onUrlRequest = impl.be;
    var key = () => key.a(onUrlChange(_Browser_getUrl()));
    return _Browser_document({
      J: sendToApp => {
        key.a = sendToApp;
        _Browser_window.addEventListener("popstate", key);
        _Browser_window.navigator.userAgent.indexOf("Trident") < 0 ||
          _Browser_window.addEventListener("hashchange", key);
        return F2((domNode, event) => {
          if (
            !event.ctrlKey &&
            !event.metaKey &&
            !event.shiftKey &&
            event.button < 1 &&
            !domNode.target &&
            !domNode.hasAttribute("download")
          ) {
            event.preventDefault();
            var href = domNode.href;
            var curr = _Browser_getUrl();
            var next = elm$url$Url$fromString(href).a;
            sendToApp(
              onUrlRequest(
                next &&
                  curr.aA === next.aA &&
                  curr.ao === next.ao &&
                  curr.ax.a === next.ax.a
                  ? elm$browser$Browser$Internal(next)
                  : elm$browser$Browser$External(href)
              )
            );
          }
        });
      },
      a2: flags => A3(impl.a2, flags, _Browser_getUrl(), key),
      bp: impl.bp,
      bn: impl.bn,
      bj: impl.bj
    });
  };
  const _Browser_getUrl = () =>
    elm$url$Url$fromString(_VirtualDom_doc.location.href).a || _Debug_crash(1);
  var _Browser_go = F2((key, n) =>
    A2(
      elm$core$Task$perform,
      elm$core$Basics$never,
      _Scheduler_binding(() => {
        n && history.go(n);
        key();
      })
    )
  );
  var _Browser_pushUrl = F2((key, url) =>
    A2(
      elm$core$Task$perform,
      elm$core$Basics$never,
      _Scheduler_binding(() => {
        history.pushState({}, "", url);
        key();
      })
    )
  );
  var _Browser_replaceUrl = F2((key, url) =>
    A2(
      elm$core$Task$perform,
      elm$core$Basics$never,
      _Scheduler_binding(() => {
        history.replaceState({}, "", url);
        key();
      })
    )
  );
  var _Browser_fakeNode = {
    addEventListener: function() {},
    removeEventListener: function() {}
  };
  var _Browser_doc =
    typeof document !== "undefined" ? document : _Browser_fakeNode;
  var _Browser_window =
    typeof window !== "undefined" ? window : _Browser_fakeNode;
  var _Browser_on = F3((node, eventName, sendToSelf) =>
    _Scheduler_spawn(
      _Scheduler_binding(callback => {
        const handler = event => _Scheduler_rawSpawn(sendToSelf(event));
        node.addEventListener(
          eventName,
          handler,
          _VirtualDom_passiveSupported && { passive: !0 }
        );
        return () => node.removeEventListener(eventName, handler);
      })
    )
  );
  var _Browser_decodeEvent = F2((decoder, event) => {
    var result = _Json_runHelp(decoder, event);
    return elm$core$Result$isOk(result)
      ? elm$core$Maybe$Just(result.a)
      : elm$core$Maybe$Nothing;
  });
  const _Browser_visibilityInfo = () =>
    typeof _VirtualDom_doc.hidden !== "undefined"
      ? { a0: "hidden", aS: "visibilitychange" }
      : typeof _VirtualDom_doc.mozHidden !== "undefined"
      ? { a0: "mozHidden", aS: "mozvisibilitychange" }
      : typeof _VirtualDom_doc.msHidden !== "undefined"
      ? { a0: "msHidden", aS: "msvisibilitychange" }
      : typeof _VirtualDom_doc.webkitHidden !== "undefined"
      ? { a0: "webkitHidden", aS: "webkitvisibilitychange" }
      : { a0: "hidden", aS: "visibilitychange" };
  const _Browser_rAF = () =>
    _Scheduler_binding(callback => {
      var id = _Browser_requestAnimationFrame(() =>
        callback(_Scheduler_succeed(Date.now()))
      );
      return () => _Browser_cancelAnimationFrame(id);
    });
  const _Browser_now = () =>
    _Scheduler_binding(callback => callback(_Scheduler_succeed(Date.now())));
  const _Browser_withNode = (id, doStuff) =>
    _Scheduler_binding(callback =>
      _Browser_requestAnimationFrame(() => {
        var node = document.getElementById(id);
        callback(
          node
            ? _Scheduler_succeed(doStuff(node))
            : _Scheduler_fail(elm$browser$Browser$Dom$NotFound(id))
        );
      })
    );
  const _Browser_withWindow = doStuff =>
    _Scheduler_binding(callback =>
      _Browser_requestAnimationFrame(() =>
        callback(_Scheduler_succeed(doStuff()))
      )
    );
  var _Browser_call = F2((functionName, id) =>
    _Browser_withNode(id, node => {
      node[functionName]();
      return _Utils_Tuple0;
    })
  );
  const _Browser_getViewport = () => {
    return {
      aG: _Browser_getScene(),
      aM: {
        S: _Browser_window.pageXOffset,
        T: _Browser_window.pageYOffset,
        E: _Browser_doc.documentElement.clientWidth,
        z: _Browser_doc.documentElement.clientHeight
      }
    };
  };
  const _Browser_getScene = () => {
    var body = _Browser_doc.body;
    var elem = _Browser_doc.documentElement;
    return {
      E: Math.max(
        body.scrollWidth,
        body.offsetWidth,
        elem.scrollWidth,
        elem.offsetWidth,
        elem.clientWidth
      ),
      z: Math.max(
        body.scrollHeight,
        body.offsetHeight,
        elem.scrollHeight,
        elem.offsetHeight,
        elem.clientHeight
      )
    };
  };
  var _Browser_setViewport = F2((x, y) =>
    _Browser_withWindow(() => {
      _Browser_window.scroll(x, y);
      return _Utils_Tuple0;
    })
  );
  const _Browser_getViewportOf = id =>
    _Browser_withNode(id, node => {
      return {
        aG: { E: node.scrollWidth, z: node.scrollHeight },
        aM: {
          S: node.scrollLeft,
          T: node.scrollTop,
          E: node.clientWidth,
          z: node.clientHeight
        }
      };
    });
  var _Browser_setViewportOf = F3((id, x, y) =>
    _Browser_withNode(id, node => {
      node.scrollLeft = x;
      node.scrollTop = y;
      return _Utils_Tuple0;
    })
  );
  const _Browser_getElement = id =>
    _Browser_withNode(id, node => {
      var rect = node.getBoundingClientRect();
      var x = _Browser_window.pageXOffset;
      var y = _Browser_window.pageYOffset;
      return {
        aG: _Browser_getScene(),
        aM: {
          S: x,
          T: y,
          E: _Browser_doc.documentElement.clientWidth,
          z: _Browser_doc.documentElement.clientHeight
        },
        aV: { S: x + rect.left, T: y + rect.top, E: rect.width, z: rect.height }
      };
    });
  const _Browser_reload = skipCache =>
    A2(
      elm$core$Task$perform,
      elm$core$Basics$never,
      _Scheduler_binding(callback => _VirtualDom_doc.location.reload(skipCache))
    );
  const _Browser_load = url =>
    A2(
      elm$core$Task$perform,
      elm$core$Basics$never,
      _Scheduler_binding(callback => {
        try {
          _Browser_window.location = url;
        } catch (err) {
          _VirtualDom_doc.location.reload(!1);
        }
      })
    );
  var author$project$Main$Success = 1;
  var author$project$Main$init = 1;
  var author$project$Main$update = F2((msg, model) => 1);
  var elm$core$Basics$identity = x => x;
  var elm$core$Basics$False = 1;
  var elm$core$Basics$True = 0;
  var elm$core$Result$isOk = result => {
    if (!result.$) {
      !0;
    } else {
      return !1;
    }
  };
  var elm$core$Array$branchFactor = 32;
  var elm$core$Array$Array_elm_builtin = F4((a, b, c, d) => {
    return { $: 0, a: a, b: b, c: c, d: d };
  });
  var elm$core$Basics$EQ = 1;
  var elm$core$Basics$GT = 2;
  var elm$core$Basics$LT = 0;
  var elm$core$Dict$foldr = F3((func, acc, t) => {
    foldr: while (!0) {
      if (t.$ === -2) {
        acc;
      } else {
        var key = t.b;
        var value = t.c;
        var left = t.d;
        var right = t.e;
        var $temp$func = func,
          $temp$acc = A3(
            func,
            key,
            value,
            A3(elm$core$Dict$foldr, func, acc, right)
          ),
          $temp$t = left;
        func = $temp$func;
        acc = $temp$acc;
        t = $temp$t;
        continue foldr;
      }
    }
  });
  var elm$core$List$cons = _List_cons;
  var elm$core$Dict$toList = dict =>
    A3(
      elm$core$Dict$foldr,
      F3((key, value, list) =>
        A2(elm$core$List$cons, _Utils_Tuple2(key, value), list)
      ),
      _List_Nil,
      dict
    );
  var elm$core$Dict$keys = dict =>
    A3(
      elm$core$Dict$foldr,
      F3((key, value, keyList) => A2(elm$core$List$cons, key, keyList)),
      _List_Nil,
      dict
    );
  var elm$core$Set$toList = _n0 => {
    var dict = _n0;
    return elm$core$Dict$keys(dict);
  };
  var elm$core$Elm$JsArray$foldr = _JsArray_foldr;
  var elm$core$Array$foldr = F3((func, baseCase, _n0) => {
    var tree = _n0.c;
    var tail = _n0.d;
    var helper = F2((node, acc) => {
      if (!node.$) {
        var subTree = node.a;
        A3(elm$core$Elm$JsArray$foldr, helper, acc, subTree);
      } else {
        var values = node.a;
        return A3(elm$core$Elm$JsArray$foldr, func, acc, values);
      }
    });
    return A3(
      elm$core$Elm$JsArray$foldr,
      helper,
      A3(elm$core$Elm$JsArray$foldr, func, baseCase, tail),
      tree
    );
  });
  var elm$core$Array$toList = array =>
    A3(elm$core$Array$foldr, elm$core$List$cons, _List_Nil, array);
  var elm$core$Basics$ceiling = _Basics_ceiling;
  var elm$core$Basics$fdiv = _Basics_fdiv;
  var elm$core$Basics$logBase = F2(
    (base, number) => _Basics_log(number) / _Basics_log(base)
  );
  var elm$core$Basics$toFloat = _Basics_toFloat;
  var elm$core$Array$shiftStep = elm$core$Basics$ceiling(
    A2(elm$core$Basics$logBase, 2, elm$core$Array$branchFactor)
  );
  var elm$core$Elm$JsArray$empty = _JsArray_empty;
  var elm$core$Array$empty = A4(
    elm$core$Array$Array_elm_builtin,
    0,
    elm$core$Array$shiftStep,
    elm$core$Elm$JsArray$empty,
    elm$core$Elm$JsArray$empty
  );
  var elm$core$Array$Leaf = a => {
    return { $: 1, a: a };
  };
  var elm$core$Array$SubTree = a => {
    return { $: 0, a: a };
  };
  var elm$core$Elm$JsArray$initializeFromList = _JsArray_initializeFromList;
  var elm$core$List$foldl = F3((func, acc, list) => {
    foldl: while (!0) {
      if (!list.b) {
        acc;
      } else {
        var x = list.a;
        var xs = list.b;
        var $temp$func = func,
          $temp$acc = A2(func, x, acc),
          $temp$list = xs;
        func = $temp$func;
        acc = $temp$acc;
        list = $temp$list;
        continue foldl;
      }
    }
  });
  var elm$core$List$reverse = list =>
    A3(elm$core$List$foldl, elm$core$List$cons, _List_Nil, list);
  var elm$core$Array$compressNodes = F2((nodes, acc) => {
    compressNodes: while (!0) {
      var _n0 = A2(
        elm$core$Elm$JsArray$initializeFromList,
        elm$core$Array$branchFactor,
        nodes
      );
      var node = _n0.a;
      var remainingNodes = _n0.b;
      var newAcc = A2(elm$core$List$cons, elm$core$Array$SubTree(node), acc);
      if (!remainingNodes.b) {
        elm$core$List$reverse(newAcc);
      } else {
        var $temp$nodes = remainingNodes,
          $temp$acc = newAcc;
        nodes = $temp$nodes;
        acc = $temp$acc;
        continue compressNodes;
      }
    }
  });
  var elm$core$Basics$apR = F2((x, f) => f(x));
  var elm$core$Basics$eq = _Utils_equal;
  var elm$core$Tuple$first = _n0 => {
    var x = _n0.a;
    return x;
  };
  var elm$core$Array$treeFromBuilder = F2((nodeList, nodeListSize) => {
    treeFromBuilder: while (!0) {
      var newNodeSize = elm$core$Basics$ceiling(
        nodeListSize / elm$core$Array$branchFactor
      );
      if (newNodeSize === 1) {
        A2(
          elm$core$Elm$JsArray$initializeFromList,
          elm$core$Array$branchFactor,
          nodeList
        ).a;
      } else {
        var $temp$nodeList = A2(
            elm$core$Array$compressNodes,
            nodeList,
            _List_Nil
          ),
          $temp$nodeListSize = newNodeSize;
        nodeList = $temp$nodeList;
        nodeListSize = $temp$nodeListSize;
        continue treeFromBuilder;
      }
    }
  });
  var elm$core$Basics$add = _Basics_add;
  var elm$core$Basics$apL = F2((f, x) => f(x));
  var elm$core$Basics$floor = _Basics_floor;
  var elm$core$Basics$gt = _Utils_gt;
  var elm$core$Basics$max = F2((x, y) => (_Utils_cmp(x, y) > 0 ? x : y));
  var elm$core$Basics$mul = _Basics_mul;
  var elm$core$Basics$sub = _Basics_sub;
  var elm$core$Elm$JsArray$length = _JsArray_length;
  var elm$core$Array$builderToArray = F2((reverseNodeList, builder) => {
    if (!builder.b) {
      A4(
        elm$core$Array$Array_elm_builtin,
        elm$core$Elm$JsArray$length(builder.d),
        elm$core$Array$shiftStep,
        elm$core$Elm$JsArray$empty,
        builder.d
      );
    } else {
      var treeLen = builder.b * elm$core$Array$branchFactor;
      var depth = elm$core$Basics$floor(
        A2(elm$core$Basics$logBase, elm$core$Array$branchFactor, treeLen - 1)
      );
      var correctNodeList = reverseNodeList
        ? elm$core$List$reverse(builder.e)
        : builder.e;
      var tree = A2(elm$core$Array$treeFromBuilder, correctNodeList, builder.b);
      return A4(
        elm$core$Array$Array_elm_builtin,
        elm$core$Elm$JsArray$length(builder.d) + treeLen,
        A2(elm$core$Basics$max, 5, depth * elm$core$Array$shiftStep),
        tree,
        builder.d
      );
    }
  });
  var elm$core$Basics$idiv = _Basics_idiv;
  var elm$core$Basics$lt = _Utils_lt;
  var elm$core$Elm$JsArray$initialize = _JsArray_initialize;
  var elm$core$Array$initializeHelp = F5(
    (fn, fromIndex, len, nodeList, tail) => {
      initializeHelp: while (!0) {
        if (fromIndex < 0) {
          A2(elm$core$Array$builderToArray, !1, {
            e: nodeList,
            b: (len / elm$core$Array$branchFactor) | 0,
            d: tail
          });
        } else {
          var leaf = elm$core$Array$Leaf(
            A3(
              elm$core$Elm$JsArray$initialize,
              elm$core$Array$branchFactor,
              fromIndex,
              fn
            )
          );
          var $temp$fn = fn,
            $temp$fromIndex = fromIndex - elm$core$Array$branchFactor,
            $temp$len = len,
            $temp$nodeList = A2(elm$core$List$cons, leaf, nodeList),
            $temp$tail = tail;
          fn = $temp$fn;
          fromIndex = $temp$fromIndex;
          len = $temp$len;
          nodeList = $temp$nodeList;
          tail = $temp$tail;
          continue initializeHelp;
        }
      }
    }
  );
  var elm$core$Basics$le = _Utils_le;
  var elm$core$Basics$remainderBy = _Basics_remainderBy;
  var elm$core$Array$initialize = F2((len, fn) => {
    if (len <= 0) {
      elm$core$Array$empty;
    } else {
      var tailLen = len % elm$core$Array$branchFactor;
      var tail = A3(
        elm$core$Elm$JsArray$initialize,
        tailLen,
        len - tailLen,
        fn
      );
      var initialFromIndex = len - tailLen - elm$core$Array$branchFactor;
      return A5(
        elm$core$Array$initializeHelp,
        fn,
        initialFromIndex,
        len,
        _List_Nil,
        tail
      );
    }
  });
  var elm$core$Maybe$Just = a => {
    return { $: 0, a: a };
  };
  var elm$core$Maybe$Nothing = { $: 1 };
  var elm$core$Result$Err = a => {
    return { $: 1, a: a };
  };
  var elm$core$Result$Ok = a => {
    return { $: 0, a: a };
  };
  var elm$json$Json$Decode$Failure = F2((a, b) => {
    return { $: 3, a: a, b: b };
  });
  var elm$json$Json$Decode$Field = F2((a, b) => {
    return { $: 0, a: a, b: b };
  });
  var elm$json$Json$Decode$Index = F2((a, b) => {
    return { $: 1, a: a, b: b };
  });
  var elm$json$Json$Decode$OneOf = a => {
    return { $: 2, a: a };
  };
  var elm$core$Basics$and = _Basics_and;
  var elm$core$Basics$append = _Utils_append;
  var elm$core$Basics$or = _Basics_or;
  var elm$core$Char$toCode = _Char_toCode;
  var elm$core$Char$isLower = _char => {
    var code = elm$core$Char$toCode(_char);
    return 97 <= code && code <= 122;
  };
  var elm$core$Char$isUpper = _char => {
    var code = elm$core$Char$toCode(_char);
    return code <= 90 && 65 <= code;
  };
  var elm$core$Char$isAlpha = _char =>
    elm$core$Char$isLower(_char) || elm$core$Char$isUpper(_char);
  var elm$core$Char$isDigit = _char => {
    var code = elm$core$Char$toCode(_char);
    return code <= 57 && 48 <= code;
  };
  var elm$core$Char$isAlphaNum = _char =>
    elm$core$Char$isLower(_char) ||
    elm$core$Char$isUpper(_char) ||
    elm$core$Char$isDigit(_char);
  var elm$core$List$length = xs =>
    A3(
      elm$core$List$foldl,
      F2((_n0, i) => i + 1),
      0,
      xs
    );
  var elm$core$List$map2 = _List_map2;
  var elm$core$List$rangeHelp = F3((lo, hi, list) => {
    rangeHelp: while (!0) {
      if (_Utils_cmp(lo, hi) < 1) {
        var $temp$lo = lo,
          $temp$hi = hi - 1,
          $temp$list = A2(elm$core$List$cons, hi, list);
        lo = $temp$lo;
        hi = $temp$hi;
        list = $temp$list;
        continue rangeHelp;
      } else {
        list;
      }
    }
  });
  var elm$core$List$range = F2((lo, hi) =>
    A3(elm$core$List$rangeHelp, lo, hi, _List_Nil)
  );
  var elm$core$List$indexedMap = F2((f, xs) =>
    A3(
      elm$core$List$map2,
      f,
      A2(elm$core$List$range, 0, elm$core$List$length(xs) - 1),
      xs
    )
  );
  var elm$core$String$all = _String_all;
  var elm$core$String$fromInt = _String_fromNumber;
  var elm$core$String$join = F2((sep, chunks) =>
    A2(_String_join, sep, _List_toArray(chunks))
  );
  var elm$core$String$uncons = _String_uncons;
  var elm$core$String$split = F2((sep, string) =>
    _List_fromArray(A2(_String_split, sep, string))
  );
  var elm$json$Json$Decode$indent = str =>
    A2(elm$core$String$join, "\n    ", A2(elm$core$String$split, "\n", str));
  var elm$json$Json$Encode$encode = _Json_encode;
  var elm$json$Json$Decode$errorOneOf = F2(
    (i, error) =>
      "\n\n(" +
      (elm$core$String$fromInt(i + 1) +
        (") " +
          elm$json$Json$Decode$indent(
            elm$json$Json$Decode$errorToString(error)
          )))
  );
  var elm$json$Json$Decode$errorToString = error =>
    A2(elm$json$Json$Decode$errorToStringHelp, error, _List_Nil);
  var elm$json$Json$Decode$errorToStringHelp = F2((error, context) => {
    errorToStringHelp: while (!0) {
      switch (error.$) {
        case 0:
          var f = error.a;
          var err = error.b;
          var isSimple = (() => {
            var _n1 = elm$core$String$uncons(f);
            if (_n1.$ === 1) {
              !1;
            } else {
              var _n2 = _n1.a;
              var _char = _n2.a;
              var rest = _n2.b;
              return (
                elm$core$Char$isAlpha(_char) &&
                A2(elm$core$String$all, elm$core$Char$isAlphaNum, rest)
              );
            }
          })();
          var fieldName = isSimple ? "." + f : "['" + (f + "']");
          var $temp$error = err,
            $temp$context = A2(elm$core$List$cons, fieldName, context);
          error = $temp$error;
          context = $temp$context;
          continue errorToStringHelp;
        case 1:
          var i = error.a;
          var err = error.b;
          var indexName = "[" + (elm$core$String$fromInt(i) + "]");
          var $temp$error = err,
            $temp$context = A2(elm$core$List$cons, indexName, context);
          error = $temp$error;
          context = $temp$context;
          continue errorToStringHelp;
        case 2:
          var errors = error.a;
          if (!errors.b) {
            return (
              "Ran into a Json.Decode.oneOf with no possibilities" +
              (() => {
                if (!context.b) {
                  ("!");
                } else {
                  return (
                    " at json" +
                    A2(elm$core$String$join, "", elm$core$List$reverse(context))
                  );
                }
              })()
            );
          } else {
            if (!errors.b.b) {
              var err = errors.a;
              var $temp$error = err,
                $temp$context = context;
              error = $temp$error;
              context = $temp$context;
              continue errorToStringHelp;
            } else {
              var starter = (() => {
                if (!context.b) {
                  ("Json.Decode.oneOf");
                } else {
                  return (
                    "The Json.Decode.oneOf at json" +
                    A2(elm$core$String$join, "", elm$core$List$reverse(context))
                  );
                }
              })();
              var introduction =
                starter +
                (" failed in the following " +
                  (elm$core$String$fromInt(elm$core$List$length(errors)) +
                    " ways:"));
              return A2(
                elm$core$String$join,
                "\n\n",
                A2(
                  elm$core$List$cons,
                  introduction,
                  A2(
                    elm$core$List$indexedMap,
                    elm$json$Json$Decode$errorOneOf,
                    errors
                  )
                )
              );
            }
          }
        default:
          var msg = error.a;
          var json = error.b;
          var introduction = (() => {
            if (!context.b) {
              ("Problem with the given value:\n\n");
            } else {
              return (
                "Problem with the value at json" +
                (A2(elm$core$String$join, "", elm$core$List$reverse(context)) +
                  ":\n\n    ")
              );
            }
          })();
          return (
            introduction +
            (elm$json$Json$Decode$indent(
              A2(elm$json$Json$Encode$encode, 4, json)
            ) +
              ("\n\n" + msg))
          );
      }
    }
  });
  var elm$json$Json$Decode$map = _Json_map1;
  var elm$json$Json$Decode$map2 = _Json_map2;
  var elm$json$Json$Decode$succeed = _Json_succeed;
  var elm$virtual_dom$VirtualDom$toHandlerInt = handler => {
    switch (handler.$) {
      case 0:
        0;
      case 1:
        return 1;
      case 2:
        return 2;
      default:
        return 3;
    }
  };
  var elm$html$Html$div = _VirtualDom_node("div");
  var elm$html$Html$h1 = _VirtualDom_node("h1");
  var elm$html$Html$header = _VirtualDom_node("header");
  var elm$html$Html$li = _VirtualDom_node("li");
  var elm$html$Html$p = _VirtualDom_node("p");
  var elm$virtual_dom$VirtualDom$text = _VirtualDom_text;
  var elm$html$Html$text = elm$virtual_dom$VirtualDom$text;
  var elm$html$Html$ul = _VirtualDom_node("ul");
  var elm$json$Json$Encode$string = _Json_wrap;
  var elm$html$Html$Attributes$stringProperty = F2((key, string) =>
    A2(_VirtualDom_property, key, elm$json$Json$Encode$string(string))
  );
  var elm$html$Html$Attributes$class = elm$html$Html$Attributes$stringProperty(
    "className"
  );
  var elm$html$Html$Attributes$id = elm$html$Html$Attributes$stringProperty(
    "id"
  );
  var author$project$Main$view = model => {
    switch (model) {
      case 0:
        A2(
          elm$html$Html$div,
          _List_fromArray([elm$html$Html$Attributes$id("elm-root")]),
          _List_fromArray([elm$html$Html$text("Loading...")])
        );
      case 2:
        return A2(
          elm$html$Html$div,
          _List_fromArray([elm$html$Html$Attributes$id("elm-root")]),
          _List_fromArray([elm$html$Html$text("Failed loading website")])
        );
      default:
        return A2(
          elm$html$Html$div,
          _List_fromArray([elm$html$Html$Attributes$id("elm-root")]),
          _List_fromArray([
            A2(
              elm$html$Html$header,
              _List_Nil,
              _List_fromArray([
                A2(
                  elm$html$Html$h1,
                  _List_Nil,
                  _List_fromArray([elm$html$Html$text("The Thaumatorium")])
                ),
                A2(
                  elm$html$Html$p,
                  _List_fromArray([elm$html$Html$Attributes$class("tagline")]),
                  _List_fromArray([
                    elm$html$Html$text("Where the magic happens")
                  ])
                )
              ])
            ),
            A2(
              elm$html$Html$p,
              _List_Nil,
              _List_fromArray([elm$html$Html$text("Welcome!")])
            ),
            A2(
              elm$html$Html$p,
              _List_Nil,
              _List_fromArray([
                elm$html$Html$text(
                  "We are based in the Netherlands. We like to take an unnormal take on things: Take a look at what the masses are doing, learning from them by NOT doing that and finding out where the good shit is at!"
                ),
                elm$html$Html$text(
                  "That doesn't mean that popular = bad. We just hate JavaScript and its ecology. Fuck JavaScript."
                )
              ])
            ),
            A2(
              elm$html$Html$div,
              _List_fromArray([elm$html$Html$Attributes$id("menu-bar")]),
              _List_fromArray([
                A2(
                  elm$html$Html$ul,
                  _List_Nil,
                  _List_fromArray([
                    A2(
                      elm$html$Html$li,
                      _List_Nil,
                      _List_fromArray([elm$html$Html$text("homepage")])
                    ),
                    A2(
                      elm$html$Html$li,
                      _List_Nil,
                      _List_fromArray([elm$html$Html$text("blog")])
                    ),
                    A2(
                      elm$html$Html$li,
                      _List_Nil,
                      _List_fromArray([elm$html$Html$text("portfolio")])
                    ),
                    A2(
                      elm$html$Html$li,
                      _List_Nil,
                      _List_fromArray([elm$html$Html$text("about")])
                    )
                  ])
                )
              ])
            )
          ])
        );
    }
  };

  var elm$core$Platform$Cmd$batch = _Platform_batch;
var elm$core$Platform$Cmd$none = elm$core$Platform$Cmd$batch(_List_Nil);
var elm$core$Platform$Sub$batch = _Platform_batch;
var elm$core$Platform$Sub$none = elm$core$Platform$Sub$batch(_List_Nil);
var elm$browser$Browser$External = a => {
  return { $: 1, a: a };
};
var elm$browser$Browser$Internal = a => {
  return { $: 0, a: a };
};
var elm$browser$Browser$Dom$NotFound = elm$core$Basics$identity;
var elm$core$Basics$never = _n0 => {
  never: while (!0) {
    var nvr = _n0;
    var $temp$_n0 = nvr;
    _n0 = $temp$_n0;
    continue never;
  }
};
var elm$core$Task$Perform = elm$core$Basics$identity;
var elm$core$Task$succeed = _Scheduler_succeed;
var elm$core$Task$init = elm$core$Task$succeed(0);
var elm$core$List$foldrHelper = F4((fn, acc, ctr, ls) => {
  if (!ls.b) {
    acc;
  } else {
    var a = ls.a;
    var r1 = ls.b;
    if (!r1.b) {
      return A2(fn, a, acc);
    } else {
      var b = r1.a;
      var r2 = r1.b;
      if (!r2.b) {
        return A2(fn, a, A2(fn, b, acc));
      } else {
        var c = r2.a;
        var r3 = r2.b;
        if (!r3.b) {
          return A2(fn, a, A2(fn, b, A2(fn, c, acc)));
        } else {
          var d = r3.a;
          var r4 = r3.b;
          var res =
            ctr > 500
              ? A3(elm$core$List$foldl, fn, acc, elm$core$List$reverse(r4))
              : A4(elm$core$List$foldrHelper, fn, acc, ctr + 1, r4);
          return A2(fn, a, A2(fn, b, A2(fn, c, A2(fn, d, res))));
        }
      }
    }
  }
});
var elm$core$List$foldr = F3((fn, acc, ls) =>
  A4(elm$core$List$foldrHelper, fn, acc, 0, ls)
);
var elm$core$List$map = F2((f, xs) =>
  A3(
    elm$core$List$foldr,
    F2((x, acc) => A2(elm$core$List$cons, f(x), acc)),
    _List_Nil,
    xs
  )
);
var elm$core$Task$andThen = _Scheduler_andThen;
var elm$core$Task$map = F2((func, taskA) =>
  A2(elm$core$Task$andThen, a => elm$core$Task$succeed(func(a)), taskA)
);
var elm$core$Task$map2 = F3((func, taskA, taskB) =>
  A2(
    elm$core$Task$andThen,
    a =>
      A2(
        elm$core$Task$andThen,
        b => elm$core$Task$succeed(A2(func, a, b)),
        taskB
      ),
    taskA
  )
);
var elm$core$Task$sequence = tasks =>
  A3(
    elm$core$List$foldr,
    elm$core$Task$map2(elm$core$List$cons),
    elm$core$Task$succeed(_List_Nil),
    tasks
  );
var elm$core$Platform$sendToApp = _Platform_sendToApp;
var elm$core$Task$spawnCmd = F2((router, _n0) => {
  var task = _n0;
  return _Scheduler_spawn(
    A2(elm$core$Task$andThen, elm$core$Platform$sendToApp(router), task)
  );
});
var elm$core$Task$onEffects = F3((router, commands, state) =>
  A2(
    elm$core$Task$map,
    _n0 => 0,
    elm$core$Task$sequence(
      A2(elm$core$List$map, elm$core$Task$spawnCmd(router), commands)
    )
  )
);
var elm$core$Task$onSelfMsg = F3((_n0, _n1, _n2) => elm$core$Task$succeed(0));
var elm$core$Task$cmdMap = F2((tagger, _n0) => {
  var task = _n0;
  return A2(elm$core$Task$map, tagger, task);
});
_Platform_effectManagers.Task = _Platform_createManager(
  elm$core$Task$init,
  elm$core$Task$onEffects,
  elm$core$Task$onSelfMsg,
  elm$core$Task$cmdMap
);
var elm$core$Task$command = _Platform_leaf("Task");
var elm$core$Task$perform = F2((toMessage, task) =>
  elm$core$Task$command(A2(elm$core$Task$map, toMessage, task))
);
var elm$core$String$length = _String_length;
var elm$core$String$slice = _String_slice;
var elm$core$String$dropLeft = F2((n, string) =>
  n < 1
    ? string
    : A3(elm$core$String$slice, n, elm$core$String$length(string), string)
);
var elm$core$String$startsWith = _String_startsWith;
var elm$url$Url$Http = 0;
var elm$url$Url$Https = 1;
var elm$core$String$indexes = _String_indexes;
var elm$core$String$isEmpty = string => string === "";
var elm$core$String$left = F2((n, string) =>
  n < 1 ? "" : A3(elm$core$String$slice, 0, n, string)
);
var elm$core$String$contains = _String_contains;
var elm$core$String$toInt = _String_toInt;
var elm$url$Url$Url = F6((protocol, host, port_, path, query, fragment) => {
  return {
    al: fragment,
    ao: host,
    av: path,
    ax: port_,
    aA: protocol,
    aB: query
  };
});
var elm$url$Url$chompBeforePath = F5((protocol, path, params, frag, str) => {
  if (elm$core$String$isEmpty(str) || A2(elm$core$String$contains, "@", str)) {
    elm$core$Maybe$Nothing;
  } else {
    var _n0 = A2(elm$core$String$indexes, ":", str);
    if (!_n0.b) {
      return elm$core$Maybe$Just(
        A6(
          elm$url$Url$Url,
          protocol,
          str,
          elm$core$Maybe$Nothing,
          path,
          params,
          frag
        )
      );
    } else {
      if (!_n0.b.b) {
        var i = _n0.a;
        var _n1 = elm$core$String$toInt(
          A2(elm$core$String$dropLeft, i + 1, str)
        );
        if (_n1.$ === 1) {
          return elm$core$Maybe$Nothing;
        } else {
          var port_ = _n1;
          return elm$core$Maybe$Just(
            A6(
              elm$url$Url$Url,
              protocol,
              A2(elm$core$String$left, i, str),
              port_,
              path,
              params,
              frag
            )
          );
        }
      } else {
        return elm$core$Maybe$Nothing;
      }
    }
  }
});
var elm$url$Url$chompBeforeQuery = F4((protocol, params, frag, str) => {
  if (elm$core$String$isEmpty(str)) {
    elm$core$Maybe$Nothing;
  } else {
    var _n0 = A2(elm$core$String$indexes, "/", str);
    if (!_n0.b) {
      return A5(elm$url$Url$chompBeforePath, protocol, "/", params, frag, str);
    } else {
      var i = _n0.a;
      return A5(
        elm$url$Url$chompBeforePath,
        protocol,
        A2(elm$core$String$dropLeft, i, str),
        params,
        frag,
        A2(elm$core$String$left, i, str)
      );
    }
  }
});
var elm$url$Url$chompBeforeFragment = F3((protocol, frag, str) => {
  if (elm$core$String$isEmpty(str)) {
    elm$core$Maybe$Nothing;
  } else {
    var _n0 = A2(elm$core$String$indexes, "?", str);
    if (!_n0.b) {
      return A4(
        elm$url$Url$chompBeforeQuery,
        protocol,
        elm$core$Maybe$Nothing,
        frag,
        str
      );
    } else {
      var i = _n0.a;
      return A4(
        elm$url$Url$chompBeforeQuery,
        protocol,
        elm$core$Maybe$Just(A2(elm$core$String$dropLeft, i + 1, str)),
        frag,
        A2(elm$core$String$left, i, str)
      );
    }
  }
});
var elm$url$Url$chompAfterProtocol = F2((protocol, str) => {
  if (elm$core$String$isEmpty(str)) {
    elm$core$Maybe$Nothing;
  } else {
    var _n0 = A2(elm$core$String$indexes, "#", str);
    if (!_n0.b) {
      return A3(
        elm$url$Url$chompBeforeFragment,
        protocol,
        elm$core$Maybe$Nothing,
        str
      );
    } else {
      var i = _n0.a;
      return A3(
        elm$url$Url$chompBeforeFragment,
        protocol,
        elm$core$Maybe$Just(A2(elm$core$String$dropLeft, i + 1, str)),
        A2(elm$core$String$left, i, str)
      );
    }
  }
});
var elm$url$Url$fromString = str =>
  A2(elm$core$String$startsWith, "http://", str)
    ? A2(
        elm$url$Url$chompAfterProtocol,
        0,
        A2(elm$core$String$dropLeft, 7, str)
      )
    : A2(elm$core$String$startsWith, "https://", str)
    ? A2(
        elm$url$Url$chompAfterProtocol,
        1,
        A2(elm$core$String$dropLeft, 8, str)
      )
    : elm$core$Maybe$Nothing;
var elm$browser$Browser$sandbox = impl =>
  _Browser_element({
    a2: _n0 => _Utils_Tuple2(impl.a2, elm$core$Platform$Cmd$none),
    bj: _n1 => elm$core$Platform$Sub$none,
    bn: F2((msg, model) =>
      _Utils_Tuple2(A2(impl.bn, msg, model), elm$core$Platform$Cmd$none)
    ),
    bp: impl.bp
  });
var author$project$Main$main = elm$browser$Browser$sandbox({
  a2: author$project$Main$init,
  bn: author$project$Main$update,
  bp: author$project$Main$view
});
_Platform_export({
  Main: { init: author$project$Main$main(elm$json$Json$Decode$succeed(0))(0) }
});
})(this);
