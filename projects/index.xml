<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>NostraDavid&#39;s&#39; programming projects on Thaumatorium</title>
    <link>http://thaumatorium.com/projects/</link>
    <description>Recent content in NostraDavid&#39;s&#39; programming projects on Thaumatorium</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 01 Jan 0001 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://thaumatorium.com/projects/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title></title>
      <link>http://thaumatorium.com/projects/canvas-projects/maze/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://thaumatorium.com/projects/canvas-projects/maze/</guid>
      <description>&lt;section&gt;&#xA;&#x9;&lt;link rel=&#34;stylesheet&#34; href=&#34;http://thaumatorium.com/projects/canvas-projects/maze.css&#34;&gt;&#xA;&#x9;&lt;h2&gt;Maze solver&lt;/h2&gt;&#xA;&#x9;&lt;p&gt;Based on &lt;a http=&#34;https://github.com/JonPizza/recursive-maze-solver&#34;&gt;JonPizza&#39;s maze solver&lt;/a&gt;, but translated to Nim&lt;/p&gt;&#xA;&#x9;&lt;p&gt;I also have a version made in &lt;a http=&#34;https://github.com/NostraDavid/MazeSolver-Nim&#34;&gt;Nim&lt;/a&gt; &lt;/p&gt;&#xA;&#x9;&lt;p&gt;&#xA;&#x9;&#x9;&lt;select id=selected-maze type=select-one&gt;&#xA;&#x9;&#x9;&#x9;&lt;option value=&#34;mazes/maze.png&#34; selected&gt;maze.png&lt;/option&gt;&#xA;&#x9;&#x9;&#x9;&lt;option value=&#34;mazes/maze2.png&#34;&gt;maze2.png&lt;/option&gt;&#xA;&#x9;&#x9;&#x9;&lt;option value=&#34;mazes/3232maze_original.png&#34;&gt;3232maze_original.png&lt;/option&gt;&#xA;&#x9;&#x9;&#x9;&lt;option value=&#34;mazes/3232maze_long.png&#34;&gt;3232maze_long.png&lt;/option&gt;&#xA;&#x9;&#x9;&#x9;&lt;option value=&#34;mazes/3232maze_longer.png&#34;&gt;3232maze_longer.png&lt;/option&gt;&#xA;&#x9;&#x9;&#x9;&lt;option value=&#34;mazes/3232maze_longest.png&#34;&gt;3232maze_longest.png&lt;/option&gt;&#xA;&#x9;&#x9;&#x9;&lt;option value=&#34;mazes/3232maze_longer_bigger.png&#34;&gt;3232maze_longer_bigger.png&lt;/option&gt;&#xA;&#x9;&#x9;&lt;/select&gt;&#xA;&#x9;&#x9;&lt;select id=maze-scale type=select-one&gt;&#xA;&#x9;&#x9;&#x9;&lt;option value=1&gt;1&lt;/option&gt;&#xA;&#x9;&#x9;&#x9;&lt;option value=2&gt;2&lt;/option&gt;&#xA;&#x9;&#x9;&#x9;&lt;option value=3&gt;3&lt;/option&gt;&#xA;&#x9;&#x9;&#x9;&lt;option value=4&gt;4&lt;/option&gt;&#xA;&#x9;&#x9;&#x9;&lt;option value=5&gt;5&lt;/option&gt;&#xA;&#x9;&#x9;&#x9;&lt;option value=6&gt;6&lt;/option&gt;&#xA;&#x9;&#x9;&#x9;&lt;option value=7&gt;7&lt;/option&gt;&#xA;&#x9;&#x9;&#x9;&lt;option value=8&gt;8&lt;/option&gt;&#xA;&#x9;&#x9;&#x9;&lt;option value=9&gt;9&lt;/option&gt;&#xA;&#x9;&#x9;&#x9;&lt;option value=10 selected&gt;10&lt;/option&gt;&#xA;&#x9;&#x9;&lt;/select&gt;&#xA;&#xA;&#x9;&#x9;&lt;button id=play-animation&gt;Play animation&lt;/button&gt;&#xA;&#x9;&lt;/p&gt;&#xA;&#x9;&lt;canvas id=maze&gt;&lt;/canvas&gt;&#xA;&#x9;&lt;script type=module src=&#34;maze.mjs&#34;&gt;&lt;/script&gt;&#xA;&lt;/section&gt;</description>
    </item>
    <item>
      <title></title>
      <link>http://thaumatorium.com/projects/fenetres/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://thaumatorium.com/projects/fenetres/</guid>
      <description>&lt;!doctype html&gt;&#xA;&lt;html lang=&#34;en&#34;&gt;&#xA;&#xA;&lt;head&gt;&#xA;&#x9;&lt;meta charset=&#34;UTF-8&#34;&gt;&#xA;&#x9;&lt;meta name=&#34;viewport&#34; content=&#34;width=device-width, initial-scale=1.0&#34;&gt;&#xA;&#x9;&lt;title&gt;FenÃªtres | The Thaumatorium&lt;/title&gt;&#xA;&#x9;&lt;style&gt;&#xA;&#x9;&#x9;html,&#xA;&#x9;&#x9;body {&#xA;&#x9;&#x9;&#x9;height: 100%;&#xA;&#x9;&#x9;&#x9;overflow: hidden;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;body {&#xA;&#x9;&#x9;&#x9;background: #000;&#xA;&#x9;&#x9;&#x9;background:&#xA;&#x9;&#x9;&#x9;&#x9;url(https://s3-us-west-2.amazonaws.com/s.cdpn.io/15664/noise.png),&#xA;&#x9;&#x9;&#x9;&#x9;radial-gradient(circle, hsl(210, 29%, 7%), hsl(210, 29%, 3%));&#xA;&#x9;&#x9;&#x9;color: #fff;&#xA;&#x9;&#x9;&#x9;font-family: &#34;Century Gothic&#34;, CenturyGothic, AppleGothic, sans-serif;&#xA;&#x9;&#x9;&#x9;/* cursor: move; */&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;#draw {&#xA;&#x9;&#x9;&#x9;position: fixed;&#xA;&#x9;&#x9;&#x9;left: 0;&#xA;&#x9;&#x9;&#x9;top: 0;&#xA;&#x9;&#x9;&#x9;width: 100%;&#xA;&#x9;&#x9;&#x9;height: 100%;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;label,&#xA;&#x9;&#x9;input {&#xA;&#x9;&#x9;&#x9;vertical-align: middle;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;label {&#xA;&#x9;&#x9;&#x9;position: relative;&#xA;&#x9;&#x9;&#x9;display: inline-block;&#xA;&#x9;&#x9;&#x9;margin: 5px;&#xA;&#x9;&#x9;&#x9;padding: 5px 10px;&#xA;&#x9;&#x9;&#x9;user-select: none;&#xA;&#x9;&#x9;&#x9;z-index: 2;&#xA;&#x9;&#x9;&#x9;cursor: pointer;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;#debug {&#xA;&#x9;&#x9;&#x9;position: absolute;&#xA;&#x9;&#x9;&#x9;bottom: 0;&#xA;&#x9;&#x9;&#x9;left: 0;&#xA;&#x9;&#x9;&#x9;color: #fff;&#xA;&#x9;&#x9;&#x9;font-family: Consolas, monaco, monospace;&#xA;&#x9;&#x9;&#x9;font-size: 1.5rem;&#xA;&#x9;&#x9;&#x9;white-space: pre;&#xA;&#x9;&#x9;}&#xA;&#x9;&lt;/style&gt;&#xA;&lt;/head&gt;&#xA;&#xA;&lt;body&gt;&#xA;&#x9;&lt;!-- original source: https://codepen.io/bali_balo/pen/yJOmgv --&gt;&#xA;&#x9;&lt;label&gt;&lt;input checked id=&#39;autoRotate&#39; type=&#39;checkbox&#39;&gt; Auto rotation&lt;/label&gt;&#xA;&#x9;&lt;div id=&#39;debug&#39;&gt;&lt;/div&gt;&#xA;&#x9;&lt;canvas id=&#39;draw&#39;&gt;&lt;/canvas&gt;&#xA;&#xA;&#x9;&lt;script&gt;&#xA;&#x9;&#x9;let _debug = document.getElementById(&#39;debug&#39;);&#xA;&#x9;&#x9;const debug = () =&gt; _debug.textContent = [].join.call(arguments, &#39;\n&#39;)&#xA;&#xA;&#x9;&#x9;let c = document.getElementById(&#39;draw&#39;),&#xA;&#x9;&#x9;&#x9;ctx = c.getContext(&#39;2d&#39;);&#xA;&#xA;&#x9;&#x9;const onResize = () =&gt; {&#xA;&#x9;&#x9;&#x9;c.width = c.clientWidth;&#xA;&#x9;&#x9;&#x9;c.height = c.clientHeight;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;window.addEventListener(&#39;resize&#39;, onResize);&#xA;&#x9;&#x9;onResize();&#xA;&#xA;&#x9;&#x9;// Utils&#xA;&#x9;&#x9;const clip = (n, m, M) =&gt; n &lt; M ? n &gt; m ? n : m : M&#xA;&#x9;&#x9;function comeCloser(n, goal, factor, limit) {&#xA;&#x9;&#x9;&#x9;return (limit &amp;&amp; Math.abs(goal - n) &lt; limit) ? goal : n + (goal - n) / (factor || 10);&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;function dist(a, b) {&#xA;&#x9;&#x9;&#x9;let dx = b[0] - a[0], dy = b[1] - a[1], dz = b[2] - a[2];&#xA;&#x9;&#x9;&#x9;return Math.sqrt(dx * dx + dy * dy + dz * dz);&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;function normalize(v) {&#xA;&#x9;&#x9;&#x9;let l = Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);&#xA;&#x9;&#x9;&#x9;return [v[0] / l, v[1] / l, v[2] / l];&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;function projection(p, d, s) {&#xA;&#x9;&#x9;&#x9;let f = (s || 1) / (1 - p[2] / d);&#xA;&#x9;&#x9;&#x9;return [p[0] * f, p[1] * f, p[2]];&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;function rotateX(p, a) {&#xA;&#x9;&#x9;&#x9;let d = Math.sqrt(p[2] * p[2] + p[1] * p[1]),&#xA;&#x9;&#x9;&#x9;&#x9;na = Math.atan2(p[2], p[1]) + a;&#xA;&#x9;&#x9;&#x9;return [p[0], d * Math.cos(na), d * Math.sin(na)];&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;function rotateY(p, a) {&#xA;&#x9;&#x9;&#x9;let d = Math.sqrt(p[2] * p[2] + p[0] * p[0]),&#xA;&#x9;&#x9;&#x9;&#x9;na = Math.atan2(p[0], p[2]) + a;&#xA;&#x9;&#x9;&#x9;return [d * Math.sin(na), p[1], d * Math.cos(na)];&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;function rotateZ(p, a) {&#xA;&#x9;&#x9;&#x9;let d = Math.sqrt(p[1] * p[1] + p[0] * p[0]),&#xA;&#x9;&#x9;&#x9;&#x9;na = Math.atan2(p[1], p[0]) + a;&#xA;&#x9;&#x9;&#x9;return [d * Math.cos(na), d * Math.sin(na), p[2]];&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;function rotateMatrix(p, m) {&#xA;&#x9;&#x9;&#x9;return [&#xA;&#x9;&#x9;&#x9;&#x9;p[0] * m[0] + p[1] * m[3] + p[2] * m[6],&#xA;&#x9;&#x9;&#x9;&#x9;p[0] * m[1] + p[1] * m[4] + p[2] * m[7],&#xA;&#x9;&#x9;&#x9;&#x9;p[0] * m[2] + p[1] * m[5] + p[2] * m[8]&#xA;&#x9;&#x9;&#x9;];&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;// Not used there but could be useful ! (gives the invert rotation)&#xA;&#x9;&#x9;function transpose33(m) {&#xA;&#x9;&#x9;&#x9;return [&#xA;&#x9;&#x9;&#x9;&#x9;m[0], m[3], m[6],&#xA;&#x9;&#x9;&#x9;&#x9;m[1], m[4], m[7],&#xA;&#x9;&#x9;&#x9;&#x9;m[2], m[5], m[8]&#xA;&#x9;&#x9;&#x9;];&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;function rotate3dMatrix(x, y, z, a) {&#xA;&#x9;&#x9;&#x9;let c = 1 - Math.cos(a), s = Math.sin(a);&#xA;&#x9;&#x9;&#x9;return [&#xA;&#x9;&#x9;&#x9;&#x9;1 + c * (x * x - 1), x * y * c + z * s, x * z * c - y * s,&#xA;&#x9;&#x9;&#x9;&#x9;x * y * c - z * s, 1 + c * (y * y - 1), y * z * c + x * s,&#xA;&#x9;&#x9;&#x9;&#x9;x * z * c + y * s, y * z * c - x * s, 1 + c * (z * z - 1)&#xA;&#x9;&#x9;&#x9;];&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;function mul33(m, n) {&#xA;&#x9;&#x9;&#x9;let m1 = m[0], m2 = m[1], m3 = m[2],&#xA;&#x9;&#x9;&#x9;&#x9;m4 = m[3], m5 = m[4], m6 = m[5],&#xA;&#x9;&#x9;&#x9;&#x9;m7 = m[6], m8 = m[7], m9 = m[8];&#xA;&#xA;&#x9;&#x9;&#x9;let n1 = n[0], n2 = n[1], n3 = n[2],&#xA;&#x9;&#x9;&#x9;&#x9;n4 = n[3], n5 = n[4], n6 = n[5],&#xA;&#x9;&#x9;&#x9;&#x9;n7 = n[6], n8 = n[7], n9 = n[8];&#xA;&#xA;&#x9;&#x9;&#x9;return [&#xA;&#x9;&#x9;&#x9;&#x9;m1 * n1 + m4 * n2 + m7 * n3, m2 * n1 + m5 * n2 + m8 * n3, m3 * n1 + m6 * n2 + m9 * n3,&#xA;&#x9;&#x9;&#x9;&#x9;m1 * n4 + m4 * n5 + m7 * n6, m2 * n4 + m5 * n5 + m8 * n6, m3 * n4 + m6 * n5 + m9 * n6,&#xA;&#x9;&#x9;&#x9;&#x9;m1 * n7 + m4 * n8 + m7 * n9, m2 * n7 + m5 * n8 + m8 * n9, m3 * n7 + m6 * n8 + m9 * n9&#xA;&#x9;&#x9;&#x9;];&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;function chainMul33(base) {&#xA;&#x9;&#x9;&#x9;for (let i = 1, l = arguments.length; i &lt; l; i++)&#xA;&#x9;&#x9;&#x9;&#x9;base = mul33(base, arguments[i]);&#xA;&#x9;&#x9;&#x9;return base;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;function dot(a, b) {&#xA;&#x9;&#x9;&#x9;return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;function cross(a, b) {&#xA;&#x9;&#x9;&#x9;return [&#xA;&#x9;&#x9;&#x9;&#x9;a[1] * b[2] - a[2] * b[1],&#xA;&#x9;&#x9;&#x9;&#x9;a[2] * b[0] - a[0] * b[2],&#xA;&#x9;&#x9;&#x9;&#x9;a[0] * b[1] - a[1] * b[0]&#xA;&#x9;&#x9;&#x9;];&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;function sub(a, b) {&#xA;&#x9;&#x9;&#x9;return [a[0] - b[0], a[1] - b[1], a[2] - b[2]];&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;// Big chunk of code incoming !&#xA;&#x9;&#x9;// These are the drawing functions&#xA;&#x9;&#x9;// You should probably fold these functions and only open one at a time&#xA;&#x9;&#x9;let drawElectricity = (function () {&#xA;&#x9;&#x9;&#x9;// let color = &#39;hsl(&#39;+(Math.random() * 360)+&#39;, 60%, 50%)&#39;;&#xA;&#x9;&#x9;&#x9;let color = &#39;rgb(40,130,240)&#39;;&#xA;&#x9;&#x9;&#x9;let rays = [];&#xA;&#x9;&#x9;&#x9;for (let i = 0; i &lt; 5; i++) {&#xA;&#x9;&#x9;&#x9;&#x9;let dest = [Math.random() - .5, Math.random() - .5, Math.random() - .5];&#xA;&#x9;&#x9;&#x9;&#x9;let d = Math.sqrt(dest[0] * dest[0] + dest[1] * dest[1] + dest[2] * dest[2]);&#xA;&#x9;&#x9;&#x9;&#x9;dest[0] /= d; dest[1] /= d; dest[2] /= d;&#xA;&#x9;&#x9;&#x9;&#x9;let parts = [], pCount = ~~(3 * Math.random()) + 3;&#xA;&#x9;&#x9;&#x9;&#x9;for (let j = 0; j &lt; pCount; j++) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;parts.push({&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;pos: (j + 1) / (pCount + 1),&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;off: [0, 0, 0],&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;maxOff: 4 + 3 * Math.random(),&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;speed: 240&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;});&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;let vel = 3;&#xA;&#x9;&#x9;&#x9;&#x9;let ray = {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;dest: dest,&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;vel: [vel * (Math.random() - .5), vel * (Math.random() - .5), vel * (Math.random() - .5)],&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;parts: parts&#xA;&#x9;&#x9;&#x9;&#x9;};&#xA;&#x9;&#x9;&#x9;&#x9;rays.push(ray);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;let tmpC = [document.createElement(&#39;canvas&#39;), document.createElement(&#39;canvas&#39;)],&#xA;&#x9;&#x9;&#x9;&#x9;tCtx = [tmpC[0].getContext(&#39;2d&#39;), tmpC[1].getContext(&#39;2d&#39;)];&#xA;&#x9;&#x9;&#x9;tmpC[0].width = tmpC[0].height = tmpC[1].width = tmpC[1].height = 200;&#xA;&#x9;&#x9;&#x9;tCtx[0].translate(100, 100); tCtx[1].translate(100, 100);&#xA;&#x9;&#x9;&#x9;let currentCanvas = 0;&#xA;&#x9;&#x9;&#x9;let counter = 0, pT;&#xA;&#x9;&#x9;&#x9;return function (ctx, faces, allCorners) {&#xA;&#x9;&#x9;&#x9;&#x9;let now = Date.now(), dt = 0;&#xA;&#x9;&#x9;&#x9;&#x9;if (pT) dt = (now - pT) * .001;&#xA;&#x9;&#x9;&#x9;&#x9;pT = now;&#xA;&#x9;&#x9;&#x9;&#x9;let c = ctx.canvas;&#xA;&#x9;&#x9;&#x9;&#x9;let rad = cubeSize * (.2 + .02 * Math.sin((counter += dt) * 2));&#xA;&#x9;&#x9;&#x9;&#x9;let mx = c.width * .5, my = c.height * .5;&#xA;&#x9;&#x9;&#x9;&#x9;ctx.strokeStyle = color;&#xA;&#x9;&#x9;&#x9;&#x9;ctx.beginPath();&#xA;&#x9;&#x9;&#x9;&#x9;ctx.arc(0, 0, rad, 0, 2 * Math.PI);&#xA;&#x9;&#x9;&#x9;&#x9;let i, l, j, l2;&#xA;&#x9;&#x9;&#x9;&#x9;for (i = 0, l = allCorners.length; i &lt; l; i++) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;let corner = allCorners[i];&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;let dx = corner[0] - mx, dy = corner[1] - my;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;let d = Math.sqrt(dx * dx + dy * dy);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (d &lt;= rad) continue;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;ctx.moveTo(rad * dx / d, rad * dy / d);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;ctx.lineTo(dx, dy);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;ctx.stroke();&#xA;&#x9;&#x9;&#x9;&#x9;currentCanvas = 1 - currentCanvas;&#xA;&#x9;&#x9;&#x9;&#x9;let cc = tmpC[currentCanvas], cCtx = tCtx[currentCanvas];&#xA;&#x9;&#x9;&#x9;&#x9;cCtx.clearRect(-cc.width * .5, -cc.height * .5, cc.width, cc.height);&#xA;&#x9;&#x9;&#x9;&#x9;cCtx.shadowColor = &#39;transparent&#39;;&#xA;&#x9;&#x9;&#x9;&#x9;cCtx.shadowBlur = 0;&#xA;&#x9;&#x9;&#x9;&#x9;cCtx.globalAlpha = Math.pow(.001, dt);&#xA;&#x9;&#x9;&#x9;&#x9;cCtx.drawImage(tmpC[1 - currentCanvas], -cc.width * .5, -cc.height * .5);&#xA;&#x9;&#x9;&#x9;&#x9;cCtx.globalAlpha = 1;&#xA;&#x9;&#x9;&#x9;&#x9;cCtx.strokeStyle = &#39;rgba(245,250,255,1)&#39;;&#xA;&#x9;&#x9;&#x9;&#x9;cCtx.shadowColor = &#39;rgba(255,255,255,.5)&#39;;&#xA;&#x9;&#x9;&#x9;&#x9;cCtx.shadowBlur = 4;&#xA;&#x9;&#x9;&#x9;&#x9;for (i = 0, l = rays.length; i &lt; l; i++) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;let ray = rays[i], vel = ray.vel;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;let dest = ray.dest = rotateX(rotateY(rotateZ(ray.dest, vel[2] * dt), vel[1] * dt), vel[0] * dt);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;let previous = [0, 0];&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;// cCtx.beginPath();&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;// cCtx.moveTo(0,0);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;for (j = 0, l2 = ray.parts.length; j &lt; l2; j++) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;let part = ray.parts[j], off = part.off;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;off[0] += part.speed * (Math.random() - .5) * dt;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;off[1] += part.speed * (Math.random() - .5) * dt;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;off[2] += part.speed * (Math.random() - .5) * dt;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;let d = Math.sqrt(off[0] * off[0] + off[1] * off[1] + off[2] * off[2]);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (d &gt; part.maxOff) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;let m = part.maxOff / d;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;off[0] *= m; off[1] *= m; off[2] *= m;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;let pos = [part.pos * rad * dest[0] + off[0], part.pos * rad * dest[1] + off[1]];&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;cCtx.lineWidth = .1 + .8 * (1 - part.pos);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;cCtx.beginPath();&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;cCtx.moveTo(previous[0], previous[1]);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;cCtx.lineTo(pos[0], pos[1]);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;cCtx.stroke();&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;previous = pos;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;cCtx.lineWidth = .15;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;cCtx.beginPath();&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;cCtx.moveTo(previous[0], previous[1]);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;cCtx.lineTo(rad * dest[0], rad * dest[1]);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;cCtx.stroke();&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;ctx.drawImage(cc, -cc.width * .5, -cc.height * .5);&#xA;&#x9;&#x9;&#x9;};&#xA;&#x9;&#x9;})();&#xA;&#x9;&#x9;let drawStars = (function () {&#xA;&#x9;&#x9;&#x9;let stars = [], focale = 100;&#xA;&#x9;&#x9;&#x9;let maxDist = 1000, f = .5 * maxDist / focale;&#xA;&#x9;&#x9;&#x9;let newStar = function (dist, c, bop) {&#xA;&#x9;&#x9;&#x9;&#x9;let speed = 400 + Math.random() * 200;&#xA;&#x9;&#x9;&#x9;&#x9;return [(Math.random() - .5) * f, (Math.random() - .5) * f, dist, speed, bop || 0];&#xA;&#x9;&#x9;&#x9;};&#xA;&#x9;&#x9;&#x9;for (let i = 0; i &lt; 200; i++) {&#xA;&#x9;&#x9;&#x9;&#x9;let dist = maxDist * Math.random() + 1;&#xA;&#x9;&#x9;&#x9;&#x9;stars.push(newStar(dist, c, 1));&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;let pT, dtMax = 1 / 60;&#xA;&#x9;&#x9;&#x9;return function (ctx) {&#xA;&#x9;&#x9;&#x9;&#x9;let now = Date.now(), dt = 0;&#xA;&#x9;&#x9;&#x9;&#x9;if (pT) dt = Math.min((now - pT) * .001, dtMax);&#xA;&#x9;&#x9;&#x9;&#x9;pT = now;&#xA;&#x9;&#x9;&#x9;&#x9;let c = ctx.canvas;&#xA;&#x9;&#x9;&#x9;&#x9;ctx.fillStyle = &#39;rgba(0,0,0,.8)&#39;;&#xA;&#x9;&#x9;&#x9;&#x9;ctx.fillRect(c.width * -.5, c.height * -.5, c.width, c.height);&#xA;&#x9;&#x9;&#x9;&#x9;for (let i = 0, l = stars.length; i &lt; l; i++) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;let star = stars[i];&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;star[4] += dt * .5;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;star[2] -= dt * star[3];&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (star[2] &lt;= 0)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;star = stars[i] = newStar(maxDist, c);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;let op = Math.min(star[4], 1);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;ctx.fillStyle = &#39;rgba(255,255,255,&#39; + op + &#39;)&#39;;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;let f = focale / star[2], s = 3 * f;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;ctx.fillRect(cubeSize * star[0] * f - s * .5, cubeSize * star[1] * f - s * .5, s, s);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;};&#xA;&#x9;&#x9;})();&#xA;&#x9;&#x9;let drawCubes = (function () {&#xA;&#x9;&#x9;&#x9;let v = [], e = [];&#xA;&#x9;&#x9;&#x9;v.push([-1, -1, -1]);&#xA;&#x9;&#x9;&#x9;v.push([-1, -1, 1]);&#xA;&#x9;&#x9;&#x9;v.push([1, -1, 1]);&#xA;&#x9;&#x9;&#x9;v.push([1, -1, -1]);&#xA;&#x9;&#x9;&#x9;v.push([1, 1, -1]);&#xA;&#x9;&#x9;&#x9;v.push([-1, 1, -1]);&#xA;&#x9;&#x9;&#x9;v.push([-1, 1, 1]);&#xA;&#x9;&#x9;&#x9;v.push([1, 1, 1]);&#xA;&#x9;&#x9;&#x9;let eFull = &#39;0-1 1-2 2-3 3-0 4-5 5-6 6-7 7-4 0-5 1-6 2-7 3-4&#39;.split(&#39; &#39;);&#xA;&#x9;&#x9;&#x9;for (let i = eFull.length, ea; i--;) e.push([+(ea = eFull[i].split(&#39;-&#39;))[0], +ea[1]]);&#xA;&#x9;&#x9;&#x9;let offset = Math.PI * .25, s1 = .5 / Math.sqrt(3), s2 = s1 / Math.sqrt(3), s3 = s2 / Math.sqrt(3);&#xA;&#x9;&#x9;&#x9;let draws = [&#xA;&#x9;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;color: &#39;#2ecc71&#39;,&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;transform: function (p, m) { return projection(rotateX(rotateMatrix(p, m), offset), perspective, cubeSize * s1); }&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;// transform: function(p, m) { return projection(rotateMatrix(rotateX(p, offset), m), f, s1); }&#xA;&#x9;&#x9;&#x9;&#x9;}, {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;color: &#39;#e74c3c&#39;,&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;transform: function (p, m) { return projection(rotateY(rotateMatrix(p, m), offset), perspective, cubeSize * s2); }&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;// transform: function(p, m) { return projection(rotateMatrix(rotateY(p, offset), m), f, s2); }&#xA;&#x9;&#x9;&#x9;&#x9;}, {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;color: &#39;#f1c40f&#39;,&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;transform: function (p, m) { return projection(rotateZ(rotateMatrix(p, m), offset), perspective, cubeSize * s3); }&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;// transform: function(p, m) { return projection(rotateMatrix(rotateZ(p, offset), m), f, s3); }&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;];&#xA;&#x9;&#x9;&#x9;return function (ctx) {&#xA;&#x9;&#x9;&#x9;&#x9;// let y = Math.asin(rot[6]),&#xA;&#x9;&#x9;&#x9;&#x9;// &#x9;x = Math.atan2(-rot[7], rot[8]),&#xA;&#x9;&#x9;&#x9;&#x9;// &#x9;z = Math.atan2(-rot[3], rot[0]);&#xA;&#x9;&#x9;&#x9;&#x9;// debug(180 * x / Math.PI, 180 * y / Math.PI, 180 * z / Math.PI);&#xA;&#x9;&#x9;&#x9;&#x9;let allLines = [], i, l, d;&#xA;&#x9;&#x9;&#x9;&#x9;for (d = draws.length; d--;) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;let draw = draws[d];&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;let points = [];&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;for (i = 0, l = v.length; i &lt; l; i++)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;points.push(draw.transform(v[i], rotMatrix));&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;for (i = e.length; i--;) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;let edge = e[i], p1 = points[edge[0]], p2 = points[edge[1]];&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;let z = (p1[2] + p2[2]) * .5;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;allLines.push([p1[0], p1[1], p2[0], p2[1], z, draw.color]);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;// Order by z-distance to get a better look&#xA;&#x9;&#x9;&#x9;&#x9;// (inverse because the next loop is decrementing)&#xA;&#x9;&#x9;&#x9;&#x9;allLines.sort(function (a, b) { return b[4] - a[4]; });&#xA;&#x9;&#x9;&#x9;&#x9;ctx.lineWidth = 1.2;&#xA;&#x9;&#x9;&#x9;&#x9;// ctx.globalCompositeOperation = &#39;lighter&#39;;&#xA;&#x9;&#x9;&#x9;&#x9;for (i = allLines.length; i--;) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;l = allLines[i];&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;ctx.strokeStyle = l[5];&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;ctx.beginPath();&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;ctx.moveTo(l[0], l[1]);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;ctx.lineTo(l[2], l[3]);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;ctx.stroke();&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;};&#xA;&#x9;&#x9;})();&#xA;&#x9;&#x9;let drawPhysics = (function () {&#xA;&#x9;&#x9;&#x9;// Using array for better perfs&#xA;&#x9;&#x9;&#x9;// 0: x, 1: y, 2: z, 3: px, 4: py, 5: pz&#xA;&#x9;&#x9;&#x9;function Point(x, y, z) { return [x, y, z, x, y, z]; }&#xA;&#x9;&#x9;&#x9;function Stick(a, b, l, style) { return [a, b, l, style]; }&#xA;&#x9;&#x9;&#x9;let points = [], sticks = [], objects = [];&#xA;&#x9;&#x9;&#x9;let tr = [0, 0, 0], defStyle = &#39;white&#39;;&#xA;&#x9;&#x9;&#x9;let sticksCache = {}; // Used to remove duplicates&#xA;&#x9;&#x9;&#x9;function setTranslation(x, y, z) { tr = [x, y, z]; }&#xA;&#x9;&#x9;&#x9;function addPoint(x, y, z) {&#xA;&#x9;&#x9;&#x9;&#x9;return points.push(Point(tr[0] + x, tr[1] + y, tr[2] + z)) - 1;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;function addStick(a, b, style, length) {&#xA;&#x9;&#x9;&#x9;&#x9;let id = Math.min(a, b) + &#39;|&#39; + Math.max(a, b);&#xA;&#x9;&#x9;&#x9;&#x9;if (sticksCache.hasOwnProperty(id))&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;return sticksCache[id];&#xA;&#x9;&#x9;&#x9;&#x9;if (length === undefined) length = dist(points[a], points[b]);&#xA;&#x9;&#x9;&#x9;&#x9;return (sticksCache[id] = sticks.push(Stick(a, b, length, style === undefined ? defStyle : style)) - 1);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;function addTriangle(a, b, c, h, style) {&#xA;&#x9;&#x9;&#x9;&#x9;// h = 0;&#xA;&#x9;&#x9;&#x9;&#x9;style = style || defStyle;&#xA;&#x9;&#x9;&#x9;&#x9;addStick(a, b, !(h &amp; 0x100) &amp;&amp; style);&#xA;&#x9;&#x9;&#x9;&#x9;addStick(b, c, !(h &amp; 0x010) &amp;&amp; style);&#xA;&#x9;&#x9;&#x9;&#x9;addStick(c, a, !(h &amp; 0x001) &amp;&amp; style);&#xA;&#x9;&#x9;&#x9;&#x9;return [a, b, c];&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;function addBox(s, x, y, z, style, parent) {&#xA;&#x9;&#x9;&#x9;&#x9;if (style) defStyle = style;&#xA;&#x9;&#x9;&#x9;&#x9;setTranslation(x, y, z);&#xA;&#x9;&#x9;&#x9;&#x9;let p1 = addPoint(-s, -s, -s),&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;p2 = addPoint(-s, -s, s),&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;p3 = addPoint(s, -s, s),&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;p4 = addPoint(s, -s, -s),&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;p5 = addPoint(-s, s, -s),&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;p6 = addPoint(-s, s, s),&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;p7 = addPoint(s, s, s),&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;p8 = addPoint(s, s, -s);&#xA;&#x9;&#x9;&#x9;&#x9;let object = [parent, [p1, p2, p3, p4, p5, p6, p7, p8]];&#xA;&#x9;&#x9;&#x9;&#x9;// clockwise points&#xA;&#x9;&#x9;&#x9;&#x9;object.push(addTriangle(p1, p3, p2, 0x100));&#xA;&#x9;&#x9;&#x9;&#x9;object.push(addTriangle(p1, p4, p3));&#xA;&#x9;&#x9;&#x9;&#x9;object.push(addTriangle(p1, p6, p5, 0x100));&#xA;&#x9;&#x9;&#x9;&#x9;object.push(addTriangle(p1, p2, p6));&#xA;&#x9;&#x9;&#x9;&#x9;object.push(addTriangle(p1, p5, p4, 0x010));&#xA;&#x9;&#x9;&#x9;&#x9;object.push(addTriangle(p4, p5, p8));&#xA;&#x9;&#x9;&#x9;&#x9;object.push(addTriangle(p2, p7, p6, 0x100));&#xA;&#x9;&#x9;&#x9;&#x9;object.push(addTriangle(p2, p3, p7));&#xA;&#x9;&#x9;&#x9;&#x9;object.push(addTriangle(p3, p4, p8, 0x001));&#xA;&#x9;&#x9;&#x9;&#x9;object.push(addTriangle(p3, p8, p7));&#xA;&#x9;&#x9;&#x9;&#x9;object.push(addTriangle(p5, p6, p7, 0x001));&#xA;&#x9;&#x9;&#x9;&#x9;object.push(addTriangle(p5, p7, p8));&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;// Reinforce by adding sticks (could also add every face other diagonal)&#xA;&#x9;&#x9;&#x9;&#x9;addStick(p1, p7, null);&#xA;&#x9;&#x9;&#x9;&#x9;addStick(p2, p8, null);&#xA;&#x9;&#x9;&#x9;&#x9;addStick(p3, p5, null);&#xA;&#x9;&#x9;&#x9;&#x9;addStick(p4, p6, null);&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;// Init spin&#xA;&#x9;&#x9;&#x9;&#x9;// p1[3] += (Math.random()-.5)*.3;&#xA;&#x9;&#x9;&#x9;&#x9;// p1[4] += (Math.random()-.5)*.3;&#xA;&#x9;&#x9;&#x9;&#x9;// p1[5] += (Math.random()-.5)*.3;&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;return objects.push(object) - 1;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;function addTetrahedron(s, x, y, z, style, parent) {&#xA;&#x9;&#x9;&#x9;&#x9;if (style) defStyle = style;&#xA;&#x9;&#x9;&#x9;&#x9;setTranslation(x, y, z);&#xA;&#x9;&#x9;&#x9;&#x9;let t = s;&#xA;&#x9;&#x9;&#x9;&#x9;s *= Math.SQRT2;&#xA;&#x9;&#x9;&#x9;&#x9;let p1 = addPoint(s, 0, -t),&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;p2 = addPoint(-s, 0, -t),&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;p3 = addPoint(0, -s, t),&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;p4 = addPoint(0, s, t);&#xA;&#x9;&#x9;&#x9;&#x9;let object = [parent, [p1, p2, p3, p4]];&#xA;&#x9;&#x9;&#x9;&#x9;// clockwise points&#xA;&#x9;&#x9;&#x9;&#x9;object.push(addTriangle(p1, p2, p4));&#xA;&#x9;&#x9;&#x9;&#x9;object.push(addTriangle(p1, p4, p3));&#xA;&#x9;&#x9;&#x9;&#x9;object.push(addTriangle(p1, p3, p2));&#xA;&#x9;&#x9;&#x9;&#x9;object.push(addTriangle(p2, p3, p4));&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;return objects.push(object) - 1;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;addBox(.50, 0, 0, 0, &#39;#e74c3c&#39;);&#xA;&#x9;&#x9;&#x9;addBox(.25, 0, 0, 0, &#39;#2ecc71&#39;, 0);&#xA;&#x9;&#x9;&#x9;addTetrahedron(.125, 0, 0, 0, &#39;#f1c40f&#39;, 1);&#xA;&#xA;&#x9;&#x9;&#x9;let accuracy = 3;&#xA;&#x9;&#x9;&#x9;let stiffness = 1, bounce = 0; // Adjust accordingly with accuracy&#xA;&#x9;&#x9;&#x9;let friction = .98, gravity = .003;&#xA;&#x9;&#x9;&#x9;let fBases = [[1, 0, 0], [-1, 0, 0], [0, 1, 0], [0, -1, 0], [0, 0, 1], [0, 0, -1]];&#xA;&#x9;&#x9;&#x9;let fs = [];&#xA;&#x9;&#x9;&#x9;let proj = [], lines = [];&#xA;&#x9;&#x9;&#x9;let paused = false; // [1,0,0,0,1,0,0,0,1]&#xA;&#x9;&#x9;&#x9;// document.addEventListener(&#39;mousedown&#39;, (e) =&gt; e.which === 3 &amp;&amp; (paused = paused ? false : transpose33(rotMatrix)));&#xA;&#x9;&#x9;&#x9;// document.addEventListener(&#39;contextmenu&#39;, (e) =&gt; e.preventDefault());&#xA;&#x9;&#x9;&#x9;function applyVel() {&#xA;&#x9;&#x9;&#x9;&#x9;for (let i = points.length; i--;) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;let p = points[i];&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;let vx = (p[0] - p[3]) * friction,&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;vy = (p[1] - p[4]) * friction,&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;vz = (p[2] - p[5]) * friction;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;let gVec = [0, gravity, 0];&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;// let gVec = rotateMatrix([0, gravity, 0], transpose33(rotMatrix));&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;p[3] = p[0]; p[4] = p[1]; p[5] = p[2];&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;p[0] += vx + gVec[0];&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;p[1] += vy + gVec[1];&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;p[2] += vz + gVec[2];&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;let ns = [];&#xA;&#x9;&#x9;&#x9;function constraints() {&#xA;&#x9;&#x9;&#x9;&#x9;ns = [];&#xA;&#x9;&#x9;&#x9;&#x9;// bounds (external cube)&#xA;&#x9;&#x9;&#x9;&#x9;for (let i = points.length; i--;) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;let p = points[i];&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;for (let j = fs.length; j--;) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;let f = fs[j];&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;let d = dot(p, f) - 1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (d &gt; 0) { // Outside !&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;for (let j = 0; j &lt; 3; j++) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;p[j + 3] += bounce * d * f[j];&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;p[j] -= d * f[j];&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;// Objects inside objects&#xA;&#x9;&#x9;&#x9;&#x9;for (let i = 0, l = objects.length; i &lt; l; i++) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;let o = objects[i], op = o[1];&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (typeof o[0] === &#39;number&#39;) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;let p = objects[o[0]];&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;for (let j = p.length; j-- &gt; 2;) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;let tri = p[j];&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;let p1 = tri[0], p2 = tri[1], p3 = tri[2];&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;let a = points[p1], b = points[p2], c = points[p3];&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;let n = normalize(cross(sub(b, a), sub(c, a)));&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;for (let k = op.length; k--;) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;let pt = points[op[k]];&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;let d = dot(sub(pt, a), n);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (d &gt; 0) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;for (let coord = 0; coord &lt; 3; coord++) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;let q = d * n[coord], qb = bounce * q;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;pt[coord + 3] += qb;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;pt[coord] -= q;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;// sticks lengths&#xA;&#x9;&#x9;&#x9;&#x9;for (let i = sticks.length; i--;) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;let s = sticks[i], p0 = points[s[0]], p1 = points[s[1]];&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;let dx = p1[0] - p0[0], dy = p1[1] - p0[1], dz = p1[2] - p0[2];&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;let d = Math.sqrt(dx * dx + dy * dy + dz * dz);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;let dd = s[2] - d, p = stiffness * .5 * dd / d;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;let offX = dx * p, offY = dy * p, offZ = dz * p;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;p0[0] -= offX; p0[1] -= offY; p0[2] -= offZ;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;p1[0] += offX; p1[1] += offY; p1[2] += offZ;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;function update() {&#xA;&#x9;&#x9;&#x9;&#x9;if (!paused) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;fs = [];&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;for (let i = fBases.length; i--;)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;fs.push(rotateMatrix(fBases[i], rotMatrix));&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;applyVel();&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;for (let i = accuracy; i--;)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;constraints();&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;proj = []; lines = [];&#xA;&#x9;&#x9;&#x9;&#x9;for (let i = 0, l = points.length; i &lt; l; i++)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;proj.push(projection(!paused ? points[i] : rotateMatrix(rotateMatrix(points[i], paused), rotMatrix), perspective));&#xA;&#x9;&#x9;&#x9;&#x9;for (let i = sticks.length; i--;) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;let s = sticks[i];&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (!s[3]) continue;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;let a = proj[s[0]], b = proj[s[1]];&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;lines.push([a[0], a[1], b[0], b[1], s[3], (a[2] + b[2]) * .5]);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;lines.sort(function (a, b) { return b[5] - a[5]; });&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;// Above 100fps, consider that we try to draw 2 times the same frame (so only update once)&#xA;&#x9;&#x9;&#x9;let pT, minFrameLength = 1000 / 100, time = 0;&#xA;&#x9;&#x9;&#x9;return function (ctx) {&#xA;&#x9;&#x9;&#x9;&#x9;let now = Date.now(), dt = 0;&#xA;&#x9;&#x9;&#x9;&#x9;if (pT) dt = now - pT;&#xA;&#x9;&#x9;&#x9;&#x9;pT = now;&#xA;&#x9;&#x9;&#x9;&#x9;time += dt;&#xA;&#x9;&#x9;&#x9;&#x9;if (time &gt;= minFrameLength) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;time = 0;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;update();&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;// [-1; 1]&#xA;&#x9;&#x9;&#x9;&#x9;ctx.scale(cubeSize * .5, cubeSize * .5);&#xA;&#x9;&#x9;&#x9;&#x9;// ctx.fillStyle = &#39;white&#39;;&#xA;&#x9;&#x9;&#x9;&#x9;// for(let i = points.length; i--;) {&#xA;&#x9;&#x9;&#x9;&#x9;// &#x9;let p = proj[i];&#xA;&#x9;&#x9;&#x9;&#x9;// &#x9;let size = .04 * (p[2] + 1);&#xA;&#x9;&#x9;&#x9;&#x9;// &#x9;ctx.fillRect(p[0] - size * .5, p[1] - size * .5, size, size);&#xA;&#x9;&#x9;&#x9;&#x9;// }&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;ctx.lineWidth = 2 / cubeSize;&#xA;&#x9;&#x9;&#x9;&#x9;// ctx.strokeStyle = &#39;white&#39;;&#xA;&#x9;&#x9;&#x9;&#x9;// ctx.beginPath();&#xA;&#x9;&#x9;&#x9;&#x9;for (let i = lines.length; i--;) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;let l = lines[i];&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;ctx.strokeStyle = l[4];&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;ctx.beginPath();&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;ctx.moveTo(l[0], l[1]);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;ctx.lineTo(l[2], l[3]);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;ctx.stroke();&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;// ctx.stroke();&#xA;&#x9;&#x9;&#x9;};&#xA;&#x9;&#x9;})();&#xA;&#x9;&#x9;let drawPong = (function () {&#xA;&#x9;&#x9;&#x9;// This one is a bit ugly (quickly coded)&#xA;&#x9;&#x9;&#x9;// Meant to be viewed from the right&#xA;&#x9;&#x9;&#x9;let ballSize = .05, ballSpeed = 2.5;&#xA;&#x9;&#x9;&#x9;let ball = [0, 0, 0], ballVel = [0, 0, 0];&#xA;&#x9;&#x9;&#x9;let p1 = [0, 0, 1], p2 = [0, 0, -1];&#xA;&#x9;&#x9;&#x9;let hits = [],// hitsFront = [],&#xA;&#x9;&#x9;&#x9;&#x9;hitS = .1, hitM = 2;&#xA;&#x9;&#x9;&#x9;function mirrorRandNZ(m) {&#xA;&#x9;&#x9;&#x9;&#x9;return (Math.random() + m) * (~~(Math.random() * 2) * 2 - 1);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;function start() {&#xA;&#x9;&#x9;&#x9;&#x9;let v = [mirrorRandNZ(.5), mirrorRandNZ(.5), mirrorRandNZ(.9)];&#xA;&#x9;&#x9;&#x9;&#x9;let l = ballSpeed / Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);&#xA;&#x9;&#x9;&#x9;&#x9;ballVel = [v[0] * l, v[1] * l, v[2] * l];&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;function transformed(p) {&#xA;&#x9;&#x9;&#x9;&#x9;return projection(rotateMatrix(p, rotMatrix), perspective);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;function addHit(pos, dx, dy, front) {&#xA;&#x9;&#x9;&#x9;&#x9;// (front ? hitsFront : hits).push([pos, dx, dy, 0]);&#xA;&#x9;&#x9;&#x9;&#x9;hits.push([pos, dx, dy, 0]);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;function clipV(v) {&#xA;&#x9;&#x9;&#x9;&#x9;return [clip(v[0], -1, 1), clip(v[1], -1, 1), clip(v[2], -1, 1)];&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;function hitSq(ctx, center, size, dx, dy) {&#xA;&#x9;&#x9;&#x9;&#x9;let p1 = clipV([center[0] + size * (-dx[0] - dy[0]), center[1] + size * (-dx[1] - dy[1]), center[2] + size * (-dx[2] - dy[2])]),&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;p2 = clipV([center[0] + size * (dx[0] - dy[0]), center[1] + size * (dx[1] - dy[1]), center[2] + size * (dx[2] - dy[2])]),&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;p3 = clipV([center[0] + size * (dx[0] + dy[0]), center[1] + size * (dx[1] + dy[1]), center[2] + size * (dx[2] + dy[2])]),&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;p4 = clipV([center[0] + size * (-dx[0] + dy[0]), center[1] + size * (-dx[1] + dy[1]), center[2] + size * (-dx[2] + dy[2])]);&#xA;&#x9;&#x9;&#x9;&#x9;p1 = transformed(p1); p2 = transformed(p2); p3 = transformed(p3); p4 = transformed(p4);&#xA;&#x9;&#x9;&#x9;&#x9;ctx.moveTo(p1[0], p1[1]);&#xA;&#x9;&#x9;&#x9;&#x9;ctx.lineTo(p2[0], p2[1]);&#xA;&#x9;&#x9;&#x9;&#x9;ctx.lineTo(p3[0], p3[1]);&#xA;&#x9;&#x9;&#x9;&#x9;ctx.lineTo(p4[0], p4[1]);&#xA;&#x9;&#x9;&#x9;&#x9;ctx.lineTo(p1[0], p1[1]);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;function updateDrawHit(ctx, dt, hit) {&#xA;&#x9;&#x9;&#x9;&#x9;hit[3] += dt;&#xA;&#x9;&#x9;&#x9;&#x9;let peak = hit[3] * 4, max = 0;&#xA;&#x9;&#x9;&#x9;&#x9;for (let x = -hitM; x &lt;= hitM; x++)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;for (let y = -hitM; y &lt;= hitM; y++) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;let d = 1 + Math.abs(Math.sqrt(x * x + y * y) - peak);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;let op = clip(2.5 / d - 1, 0, 1);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (op &gt; max) max = op;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;ctx.fillStyle = &#39;rgba(200,30,120,&#39; + op + &#39;)&#39;;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;// ctx.fillRect(p[0]+(x-.5)*s,p[1]+(y-.5)*s,s,s);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;ctx.beginPath();&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;let c = [hit[0][0] + hitS * ((x - .5) * hit[1][0] + (y - .5) * hit[2][0]), hit[0][1] + hitS * ((x - .5) * hit[1][1] + (y - .5) * hit[2][1]), hit[0][2] + hitS * ((x - .5) * hit[1][2] + (y - .5) * hit[2][2])];&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;hitSq(ctx, c, hitS * .5, hit[1], hit[2]);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;ctx.fill();&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;return max &gt;= .01;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;start();&#xA;&#x9;&#x9;&#x9;let pT, dtMax = 1 / 60;&#xA;&#x9;&#x9;&#x9;return function (ctx) {&#xA;&#x9;&#x9;&#x9;&#x9;let now = Date.now(), dt = 0;&#xA;&#x9;&#x9;&#x9;&#x9;if (pT) dt = Math.min((now - pT) * .001, dtMax);&#xA;&#x9;&#x9;&#x9;&#x9;pT = now;&#xA;&#x9;&#x9;&#x9;&#x9;ctx.scale(cubeSize * .5, cubeSize * .5);&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;ball[0] += ballVel[0] * dt;&#xA;&#x9;&#x9;&#x9;&#x9;ball[1] += ballVel[1] * dt;&#xA;&#x9;&#x9;&#x9;&#x9;ball[2] += ballVel[2] * dt;&#xA;&#x9;&#x9;&#x9;&#x9;if (ball[0] &lt; ballSize - 1) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;ball[0] = ballSize - 1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;ballVel[0] *= -1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;addHit([-1, ball[1], ball[2]], [0, 0, 1], [0, 1, 0]);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;if (ball[0] &gt; 1 - ballSize) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;ball[0] = 1 - ballSize;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;ballVel[0] *= -1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;// addHit([1, ball[1], ball[2]], [0,0,1], [0,1,0], true);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;if (ball[1] &lt; ballSize - 1) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;ball[1] = ballSize - 1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;ballVel[1] *= -1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;addHit([ball[0], -1, ball[2]], [1, 0, 0], [0, 0, 1]);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;if (ball[1] &gt; 1 - ballSize) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;ball[1] = 1 - ballSize;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;ballVel[1] *= -1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;addHit([ball[0], 1, ball[2]], [1, 0, 0], [0, 0, 1]);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;if (ball[2] &lt; ballSize - 1) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;ball[2] = ballSize - 1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;ballVel[2] *= -1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;// addHit([ball[0], ball[1], -1], [1,0,0], [0,1,0]);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;if (ball[2] &gt; 1 - ballSize) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;ball[2] = 1 - ballSize;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;ballVel[2] *= -1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;// addHit([ball[0], ball[1], 1], [1,0,0], [0,1,0]);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;// Should only call these once per frame&#xA;&#x9;&#x9;&#x9;&#x9;// (or find a way to use dt with it)&#xA;&#x9;&#x9;&#x9;&#x9;p1[0] = comeCloser(p1[0], ball[0], 2 + 20 * (1 - ball[2]));&#xA;&#x9;&#x9;&#x9;&#x9;p1[1] = comeCloser(p1[1], ball[1], 2 + 20 * (1 - ball[2]));&#xA;&#x9;&#x9;&#x9;&#x9;p2[0] = comeCloser(p2[0], ball[0], 2 + 20 * (ball[2] + 1));&#xA;&#x9;&#x9;&#x9;&#x9;p2[1] = comeCloser(p2[1], ball[1], 2 + 20 * (ball[2] + 1));&#xA;&#x9;&#x9;&#x9;&#x9;ctx.fillStyle = &#39;white&#39;;&#xA;&#x9;&#x9;&#x9;&#x9;ctx.beginPath();&#xA;&#x9;&#x9;&#x9;&#x9;hitSq(ctx, p1, .2, [1, 0, 0], [0, 1, 0]);&#xA;&#x9;&#x9;&#x9;&#x9;hitSq(ctx, p2, .2, [1, 0, 0], [0, 1, 0]);&#xA;&#x9;&#x9;&#x9;&#x9;ctx.fill();&#xA;&#x9;&#x9;&#x9;&#x9;hits = hits.filter(updateDrawHit.bind(this, ctx, dt));&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;let bPos = transformed(ball);&#xA;&#x9;&#x9;&#x9;&#x9;let s = ballSize / (1 - bPos[2] / perspective);&#xA;&#x9;&#x9;&#x9;&#x9;ctx.fillStyle = &#39;white&#39;;&#xA;&#x9;&#x9;&#x9;&#x9;ctx.beginPath();&#xA;&#x9;&#x9;&#x9;&#x9;ctx.arc(bPos[0], bPos[1], s, 0, 2 * Math.PI);&#xA;&#x9;&#x9;&#x9;&#x9;ctx.fill();&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;// hitsFront = hitsFront.filter(updateDrawHit.bind(this, ctx, dt));&#xA;&#x9;&#x9;&#x9;};&#xA;&#x9;&#x9;})();&#xA;&#x9;&#x9;let drawGrowing = (function () {&#xA;&#x9;&#x9;&#x9;function easing(t) {&#xA;&#x9;&#x9;&#x9;&#x9;return t &lt; .5 ? 2 * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;let globalScale = 1, globalRot = 0, rotX = -.17;&#xA;&#x9;&#x9;&#x9;function transformed(v) { return projection(rotateX(rotateY(v, globalRot), rotX), perspective); }&#xA;&#x9;&#x9;&#x9;function box(ctx, sX, sY, sZ) {&#xA;&#x9;&#x9;&#x9;&#x9;let p1 = transformed([-sX, -sY, sZ]),&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;p2 = transformed([sX, -sY, sZ]),&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;p3 = transformed([sX, sY, sZ]),&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;p4 = transformed([-sX, sY, sZ]),&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;p5 = transformed([-sX, -sY, -sZ]),&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;p6 = transformed([sX, -sY, -sZ]),&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;p7 = transformed([sX, sY, -sZ]),&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;p8 = transformed([-sX, sY, -sZ]);&#xA;&#x9;&#x9;&#x9;&#x9;ctx.moveTo(p1[0], p1[1]);&#xA;&#x9;&#x9;&#x9;&#x9;ctx.lineTo(p2[0], p2[1]);&#xA;&#x9;&#x9;&#x9;&#x9;ctx.lineTo(p3[0], p3[1]);&#xA;&#x9;&#x9;&#x9;&#x9;ctx.lineTo(p4[0], p4[1]);&#xA;&#x9;&#x9;&#x9;&#x9;ctx.lineTo(p1[0], p1[1]);&#xA;&#x9;&#x9;&#x9;&#x9;ctx.lineTo(p5[0], p5[1]);&#xA;&#x9;&#x9;&#x9;&#x9;ctx.lineTo(p6[0], p6[1]);&#xA;&#x9;&#x9;&#x9;&#x9;ctx.lineTo(p7[0], p7[1]);&#xA;&#x9;&#x9;&#x9;&#x9;ctx.lineTo(p8[0], p8[1]);&#xA;&#x9;&#x9;&#x9;&#x9;ctx.lineTo(p5[0], p5[1]);&#xA;&#x9;&#x9;&#x9;&#x9;ctx.moveTo(p2[0], p2[1]);&#xA;&#x9;&#x9;&#x9;&#x9;ctx.lineTo(p6[0], p6[1]);&#xA;&#x9;&#x9;&#x9;&#x9;ctx.moveTo(p3[0], p3[1]);&#xA;&#x9;&#x9;&#x9;&#x9;ctx.lineTo(p7[0], p7[1]);&#xA;&#x9;&#x9;&#x9;&#x9;ctx.moveTo(p4[0], p4[1]);&#xA;&#x9;&#x9;&#x9;&#x9;ctx.lineTo(p8[0], p8[1]);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;let pT, dtMax = 1 / 60, t = 0;&#xA;&#x9;&#x9;&#x9;let animDur = 2.1;&#xA;&#x9;&#x9;&#x9;return function (ctx) {&#xA;&#x9;&#x9;&#x9;&#x9;let now = Date.now(), dt = 0;&#xA;&#x9;&#x9;&#x9;&#x9;if (pT) dt = Math.min((now - pT) * .001, dtMax);&#xA;&#x9;&#x9;&#x9;&#x9;pT = now;&#xA;&#x9;&#x9;&#x9;&#x9;t += dt;&#xA;&#x9;&#x9;&#x9;&#x9;let p = (t % animDur) / animDur;&#xA;&#x9;&#x9;&#x9;&#x9;globalScale = 1 - p * .5;&#xA;&#x9;&#x9;&#x9;&#x9;globalRot = p * Math.PI / 2;&#xA;&#x9;&#x9;&#x9;&#x9;let sc = cubeSize * .2;&#xA;&#x9;&#x9;&#x9;&#x9;ctx.scale(sc, sc);&#xA;&#x9;&#x9;&#x9;&#x9;ctx.strokeStyle = &#39;#57ff57&#39;;&#xA;&#x9;&#x9;&#x9;&#x9;ctx.lineWidth = .75 / sc;&#xA;&#x9;&#x9;&#x9;&#x9;ctx.beginPath();&#xA;&#x9;&#x9;&#x9;&#x9;box(ctx, globalScale, globalScale, globalScale);&#xA;&#x9;&#x9;&#x9;&#x9;let scx = easing(clip(p / .27, 0, 1)) * 1.5 + .5,&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;scy = easing(clip((p - .27) / .27, 0, 1)) * 1.5 + .5,&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;scz = easing(clip((p - .54) / .27, 0, 1)) * 1.5 + .5;&#xA;&#x9;&#x9;&#x9;&#x9;box(ctx, globalScale * scx, globalScale * scy, globalScale * scz);&#xA;&#x9;&#x9;&#x9;&#x9;ctx.stroke();&#xA;&#x9;&#x9;&#x9;};&#xA;&#x9;&#x9;})();&#xA;&#xA;&#x9;&#x9;// Now the cube logic&#xA;&#x9;&#x9;let baseCorners = [&#xA;&#x9;&#x9;&#x9;[-1, -1, 1], [1, -1, 1], [1, 1, 1], [-1, 1, 1],&#xA;&#x9;&#x9;&#x9;[1, -1, -1], [-1, -1, -1], [-1, 1, -1], [1, 1, -1],&#xA;&#x9;&#x9;];&#xA;&#x9;&#x9;// Here are the faces of the cube&#xA;&#x9;&#x9;// You can use the same draw for multiple faces !&#xA;&#x9;&#x9;// But be careful, the function will be called for every face&#xA;&#x9;&#x9;// So if you increment something it will be incremented multiple times per frame&#xA;&#x9;&#x9;// Name is not actually used here except for human-readability (but could be used in a drawing function)&#xA;&#x9;&#x9;let faces = [&#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;name: &#39;front&#39;,&#xA;&#x9;&#x9;&#x9;&#x9;corners: [0, 1, 2, 3],&#xA;&#x9;&#x9;&#x9;&#x9;draw: drawElectricity&#xA;&#x9;&#x9;&#x9;}, {&#xA;&#x9;&#x9;&#x9;&#x9;name: &#39;back&#39;,&#xA;&#x9;&#x9;&#x9;&#x9;corners: [4, 5, 6, 7],&#xA;&#x9;&#x9;&#x9;&#x9;draw: drawGrowing&#xA;&#x9;&#x9;&#x9;&#x9;// ... empty ?&#xA;&#x9;&#x9;&#x9;&#x9;// draw: function() { return true; }&#xA;&#x9;&#x9;&#x9;&#x9;// draw: function(ctx) { let c = ctx.canvas; ctx.clearRect(-c.width*.5, -c.height*.5, c.width, c.height); }&#xA;&#x9;&#x9;&#x9;}, {&#xA;&#x9;&#x9;&#x9;&#x9;name: &#39;right&#39;,&#xA;&#x9;&#x9;&#x9;&#x9;corners: [1, 4, 7, 2],&#xA;&#x9;&#x9;&#x9;&#x9;draw: drawPong&#xA;&#x9;&#x9;&#x9;}, {&#xA;&#x9;&#x9;&#x9;&#x9;name: &#39;left&#39;,&#xA;&#x9;&#x9;&#x9;&#x9;corners: [5, 0, 3, 6],&#xA;&#x9;&#x9;&#x9;&#x9;draw: drawStars&#xA;&#x9;&#x9;&#x9;}, {&#xA;&#x9;&#x9;&#x9;&#x9;name: &#39;bottom&#39;,&#xA;&#x9;&#x9;&#x9;&#x9;corners: [3, 2, 7, 6],&#xA;&#x9;&#x9;&#x9;&#x9;draw: drawPhysics&#xA;&#x9;&#x9;&#x9;}, {&#xA;&#x9;&#x9;&#x9;&#x9;name: &#39;top&#39;,&#xA;&#x9;&#x9;&#x9;&#x9;corners: [5, 4, 1, 0],&#xA;&#x9;&#x9;&#x9;&#x9;draw: drawCubes&#xA;&#x9;&#x9;&#x9;}];&#xA;&#xA;&#x9;&#x9;// Style things&#xA;&#x9;&#x9;let faceBg = &#39;rgba(4,13,24,.65)&#39;,&#xA;&#x9;&#x9;&#x9;border = &#39;rgb(40,130,240)&#39;;&#xA;&#x9;&#x9;let cubeSize = 160, perspective = 15;&#xA;&#xA;&#x9;&#x9;// Change rot to change the initial rotation (radians)&#xA;&#x9;&#x9;// rotVel is the angular velocity in rad/sec around every axis&#xA;&#x9;&#x9;let rot = [0, 0, 0], rotVel = [-6e-3, 7.6e-3, 2.13e-3],&#xA;&#x9;&#x9;&#x9;rotBase = [1, 0, 0, 0, 1, 0, 0, 0, 1], rotMatrix;&#xA;&#x9;&#x9;// Used mainly when dragging&#xA;&#x9;&#x9;function setBase() {&#xA;&#x9;&#x9;&#x9;rotBase = rotMatrix;&#xA;&#x9;&#x9;&#x9;rot = [0, 0, 0];&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;let autoRot = document.getElementById(&#39;autoRotate&#39;);&#xA;&#x9;&#x9;autoRot.addEventListener(&#39;change&#39;, setBase);&#xA;&#xA;&#x9;&#x9;// Actual drawing loop&#xA;&#x9;&#x9;function loop() {&#xA;&#x9;&#x9;&#x9;if (autoRot.checked) {&#xA;&#x9;&#x9;&#x9;&#x9;rot[0] += rotVel[0];&#xA;&#x9;&#x9;&#x9;&#x9;rot[1] += rotVel[1];&#xA;&#x9;&#x9;&#x9;&#x9;rot[2] += rotVel[2];&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;// Compute the current rotation matrix&#xA;&#x9;&#x9;&#x9;let mx = rotate3dMatrix(1, 0, 0, rot[0]),&#xA;&#x9;&#x9;&#x9;&#x9;my = rotate3dMatrix(0, 1, 0, rot[1]),&#xA;&#x9;&#x9;&#x9;&#x9;mz = rotate3dMatrix(0, 0, 1, rot[2]);&#xA;&#x9;&#x9;&#x9;rotMatrix = chainMul33(mx, my, mz, rotBase);&#xA;&#xA;&#x9;&#x9;&#x9;let w = c.width, h = c.height;&#xA;&#x9;&#x9;&#x9;let corners = baseCorners.map(function (c) {&#xA;&#x9;&#x9;&#x9;&#x9;let res = projection(rotateMatrix(c, rotMatrix), perspective, cubeSize * .5);&#xA;&#x9;&#x9;&#x9;&#x9;res[0] += w * .5; res[1] += h * .5;&#xA;&#x9;&#x9;&#x9;&#x9;return res;&#xA;&#x9;&#x9;&#x9;});&#xA;&#x9;&#x9;&#x9;ctx.clearRect(0, 0, w, h);&#xA;&#x9;&#x9;&#x9;// Compute every face corners position and its z position&#xA;&#x9;&#x9;&#x9;for (let i = 0, l = faces.length; i &lt; l; i++) {&#xA;&#x9;&#x9;&#x9;&#x9;let face = faces[i];&#xA;&#x9;&#x9;&#x9;&#x9;let z = 0;&#xA;&#x9;&#x9;&#x9;&#x9;let faceCorners = face.currentCorners = face.corners.map(function (i) { let c = corners[i]; z += c[2]; return c; });&#xA;&#x9;&#x9;&#x9;&#x9;face.z = z * .25;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;// Sort by z to draw what is behind first&#xA;&#x9;&#x9;&#x9;faces.sort(function (a, b) { return a.z - b.z; });&#xA;&#x9;&#x9;&#x9;for (let i = 0, l = faces.length; i &lt; l; i++) {&#xA;&#x9;&#x9;&#x9;&#x9;let face = faces[i];&#xA;&#x9;&#x9;&#x9;&#x9;let faceCorners = face.currentCorners;&#xA;&#x9;&#x9;&#x9;&#x9;ctx.save();&#xA;&#x9;&#x9;&#x9;&#x9;// Clip twice : the first time to remove the face when it&#39;s not facing us&#xA;&#x9;&#x9;&#x9;&#x9;// The second time to actually only draw on the face&#xA;&#x9;&#x9;&#x9;&#x9;ctx.beginPath();&#xA;&#x9;&#x9;&#x9;&#x9;ctx.rect(0, 0, c.width, c.height);&#xA;&#x9;&#x9;&#x9;&#x9;drawPath(ctx, faceCorners);&#xA;&#x9;&#x9;&#x9;&#x9;ctx.clip();&#xA;&#x9;&#x9;&#x9;&#x9;ctx.beginPath();&#xA;&#x9;&#x9;&#x9;&#x9;drawPath(ctx, faceCorners);&#xA;&#x9;&#x9;&#x9;&#x9;ctx.clip();&#xA;&#x9;&#x9;&#x9;&#x9;let drawBg;&#xA;&#x9;&#x9;&#x9;&#x9;if (face.draw) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;ctx.save();&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;ctx.translate(w * .5, h * .5);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;drawBg = face.draw(ctx, faces, corners);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;ctx.restore();&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;// if(drawBg === undefined) drawBg = true;&#xA;&#x9;&#x9;&#x9;&#x9;ctx.restore();&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;ctx.fillStyle = faceBg;&#xA;&#x9;&#x9;&#x9;&#x9;ctx.strokeStyle = border;&#xA;&#x9;&#x9;&#x9;&#x9;ctx.lineWidth = .5;&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;// Always draw the background if facing back&#xA;&#x9;&#x9;&#x9;&#x9;ctx.save();&#xA;&#x9;&#x9;&#x9;&#x9;ctx.beginPath();&#xA;&#x9;&#x9;&#x9;&#x9;ctx.rect(c.width, 0, -c.width, c.height);&#xA;&#x9;&#x9;&#x9;&#x9;drawPath(ctx, faceCorners);&#xA;&#x9;&#x9;&#x9;&#x9;ctx.clip();&#xA;&#x9;&#x9;&#x9;&#x9;ctx.beginPath();&#xA;&#x9;&#x9;&#x9;&#x9;drawPath(ctx, faceCorners);&#xA;&#x9;&#x9;&#x9;&#x9;ctx.fill();&#xA;&#x9;&#x9;&#x9;&#x9;ctx.restore();&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;ctx.beginPath();&#xA;&#x9;&#x9;&#x9;&#x9;drawPath(ctx, faceCorners);&#xA;&#x9;&#x9;&#x9;&#x9;if (drawBg) ctx.fill();&#xA;&#x9;&#x9;&#x9;&#x9;ctx.stroke();&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;requestAnimationFrame(loop);&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;requestAnimationFrame(loop);&#xA;&#xA;&#x9;&#x9;function drawPath(ctx, corners) {&#xA;&#x9;&#x9;&#x9;if (!corners.length) return;&#xA;&#x9;&#x9;&#x9;ctx.moveTo(corners[0][0], corners[0][1]);&#xA;&#x9;&#x9;&#x9;for (let i = 0, l = corners.length; i &lt; l; i++)&#xA;&#x9;&#x9;&#x9;&#x9;ctx.lineTo(corners[i][0], corners[i][1]);&#xA;&#x9;&#x9;&#x9;ctx.lineTo(corners[0][0], corners[0][1]);&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;// Handle mouse/touch events&#xA;&#x9;&#x9;(function () {&#xA;&#x9;&#x9;&#x9;let grabbed = false, moved = false, cPos, pPos;&#xA;&#x9;&#x9;&#x9;let lastMoveTime, vel, timer;&#xA;&#x9;&#x9;&#x9;let factor = 3e-3;&#xA;&#x9;&#x9;&#x9;function getPos(e) {&#xA;&#x9;&#x9;&#x9;&#x9;if (e.touches &amp;&amp; e.touches.length)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;e = e.touches[0];&#xA;&#x9;&#x9;&#x9;&#x9;return [e.clientX, e.clientY];&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;function stopMomentum() { cancelAnimationFrame(timer); timer = null; }&#xA;&#x9;&#x9;&#x9;function mouseDown(e) {&#xA;&#x9;&#x9;&#x9;&#x9;if (grabbed) return;&#xA;&#x9;&#x9;&#x9;&#x9;if (!e.touches)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;e.preventDefault();&#xA;&#x9;&#x9;&#x9;&#x9;stopMomentum();&#xA;&#x9;&#x9;&#x9;&#x9;cPos = pPos = grabbed = getPos(e);&#xA;&#x9;&#x9;&#x9;&#x9;moved = false;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;function mouseMove(e) {&#xA;&#x9;&#x9;&#x9;&#x9;if (!grabbed) return;&#xA;&#x9;&#x9;&#x9;&#x9;let pos = getPos(e);&#xA;&#x9;&#x9;&#x9;&#x9;let dx = grabbed[1] - pos[1], dy = pos[0] - grabbed[0];&#xA;&#x9;&#x9;&#x9;&#x9;if (!moved) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (dx * dx + dy * dy &lt; 16) return;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;moved = true;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;autoRot.checked = false;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;// rotBase = getRotMatrix(getComputedStyle(cube).getPropertyValue(&#39;transform&#39;));&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;// rot = [0,0,0];&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;setBase();&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;lastMoveTime = Date.now();&#xA;&#x9;&#x9;&#x9;&#x9;pPos = cPos; cPos = pos;&#xA;&#x9;&#x9;&#x9;&#x9;rot = [dx * factor, dy * factor, 0];&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;function mouseUp(e) {&#xA;&#x9;&#x9;&#x9;&#x9;if (!grabbed) return;&#xA;&#x9;&#x9;&#x9;&#x9;grabbed = false;&#xA;&#x9;&#x9;&#x9;&#x9;if (!moved) return;&#xA;&#x9;&#x9;&#x9;&#x9;let f = Math.max(0, 1 - (Date.now() - lastMoveTime) / 200);&#xA;&#x9;&#x9;&#x9;&#x9;vel = [(pPos[1] - cPos[1]) * factor * f, (cPos[0] - pPos[0]) * factor * f];&#xA;&#x9;&#x9;&#x9;&#x9;timer = requestAnimationFrame(momentum);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;function momentum() {&#xA;&#x9;&#x9;&#x9;&#x9;if (Math.abs(vel[0]) &lt; .001 &amp;&amp; Math.abs(vel[1]) &lt; .001)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;return;&#xA;&#x9;&#x9;&#x9;&#x9;let decay = .97;&#xA;&#x9;&#x9;&#x9;&#x9;vel[0] *= decay; vel[1] *= decay;&#xA;&#x9;&#x9;&#x9;&#x9;rot[0] += vel[0]; rot[1] += vel[1];&#xA;&#x9;&#x9;&#x9;&#x9;if (timer)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;timer = requestAnimationFrame(momentum);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;document.addEventListener(&#39;mousedown&#39;, mouseDown);&#xA;&#x9;&#x9;&#x9;document.addEventListener(&#39;mousemove&#39;, mouseMove);&#xA;&#x9;&#x9;&#x9;document.addEventListener(&#39;mouseup&#39;, mouseUp);&#xA;&#x9;&#x9;&#x9;document.addEventListener(&#39;click&#39;, function (e) { if (!moved) return; e.preventDefault(); e.stopPropagation(); }, true);&#xA;&#x9;&#x9;&#x9;document.addEventListener(&#39;touchstart&#39;, mouseDown);&#xA;&#x9;&#x9;&#x9;document.addEventListener(&#39;touchmove&#39;, mouseMove);&#xA;&#x9;&#x9;&#x9;document.addEventListener(&#39;touchend&#39;, mouseUp);&#xA;&#x9;&#x9;})();&#xA;&#x9;&lt;/script&gt;&#xA;&lt;/body&gt;&#xA;&#xA;&lt;/html&gt;</description>
    </item>
  </channel>
</rss>
