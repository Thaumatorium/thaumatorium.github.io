<section>
  <h1>Types (or classes) of Haskell functions</h1>
  <p>Published: <time datetime=2018-10-15>2018-10-15</time></p>
  <p>Author: <span>NostraDavid</span></p>
  <p>
    Slightly annoying that type and class already have a certain meaning in Haskell, but I think you’re smart enough to
    understand what I mean with the Title
  </p>
  <p>
    In this context, a parser is a function accepting strings as input and returning some structure as output,
    typically a parse tree or a set of indices representing locations in the string where parsing stopped successfully.
  </p>
  <table>
    <thead>
      <th>Function typename</th>
      <th>What it does</th>
      <th>Example code</th>
    </thead>
    <tbody>
      <tr>
        <td>Pure</td>
        <td>Takes an input, returns an output – no side effects (data changes)</td>
        <td><code>f :: Int -> Int
        f x = x</code></td>
      </tr>
      <tr>
        <td>Predicate</td>
        <td>Takes an input, returns a Bool </td>
        <td><code>f :: Int -> Bool
          f x = x > 5</code></td>
      </tr>
      <tr>
        <td>Recursive</td>
        <td>Like a Pure function, but also calls itself (at least once) with a subset of the original input </td>
        <td><code>length :: [a] -> Int
          length (x:xs) = 1 + length xs</code></td>
      </tr>
      <tr>
        <td>Curried</td>
        <td>You can give a function a part of the input to create a new function (
          imperative languages like C or Python always want all arguments at once)</td>
        <td><code>timesTwo :: Int -> Int
          timesTwo = 2 *</code>
          As you can see, the * operator only has one input – It’s been partially applied!
          When you look at the definition, you see that timesTwo expects at least one Int, which when applied, gets
          added at the end of the function:
          <code>timesTwo 3
            = { apply timesTwo }
            2 * 3
            = { apply * }
            6</code>
        </td>
      </tr>
      <tr>
        <td>Applicative</td>
        <td>Can take a variable amount of inputs, returns an output </td>
        <td>Uses a function (<code>pure</code>) and an operator (<code>&lt;*&gt;</code>), where ‘pure’ lifts the
          function into a wrapped type/function and ‘<*>’ accepts a wrapped type/function and a variable (that’s also
            wrapped)
        </td>
      </tr>
      <tr>
        <td>Monadic</td>
        <td>Takes an input, returns an output – has side effects (data changes) and uses either the bind >>= operator or
          do notation</td>
        <td>From: <a href=https://wiki.haskell.org/All_About_Monads>https://wiki.haskell.org/All_About_Monads</a><code>
          maternalGrandfather :: Sheep -> Maybe Sheep
          maternalGrandfather s = (return s) >>= mother >>= father
          -- alternatively
          mothersPaternalGrandfather :: Sheep -> Maybe Sheep
          mothersPaternalGrandfather s = do m <- mother s
          gf <- father m
          father gf
          </code></td>
      </tr>
      <tr>
        <td>Parser Combinator</td>
        <td>Accepts several parsers as input and returns a new parser as its output. </td>
        <td>From: <a
            href=https://en.wikipedia.org/wiki/Parser_combinator>https://en.wikipedia.org/wiki/Parser_combinator</a>
          In this context, a parser is a function accepting strings as input and returning some structure as output,
          typically a parse tree or a set of indices representing locations in the string where parsing stopped
          successfully.
        </td>
      </tr>
    </tbody>
  </table>
</section>