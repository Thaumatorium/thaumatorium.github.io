<!DOCTYPE html>
<!-- Since I'm used to writing en-US, I'll probably make mistakes in this document. Oh well. -->
<html lang="en-GB">

<head>
  <!--
  This file is UTF-8 with BOM (Byte Order Mark) - If you're using a decent editor, you can also see this in the status bar (at the bottom of the window) - 
  This means that the meta tag with charset=utf8 isn't needed.
  You could also set Content-Type in the packet header (that's something you should set in your server software)
  You can use http://validator.w3.org/i18n-checker/ to see if your header encoding to UTF-8
  For more information: https://www.w3.org/International/questions/qa-html-encoding-declarations#nonutf8
  -->
  <!-- <meta charset="utf-8" /> -->
  <!-- The title of the tab -->
  <title>Thaumatorium</title>
  <!-- <base href="https://thaumatorium.com/" /> -->
  <base href="/" />
  <!-- This description should show up in Google results -->
  <meta name=description content="Where the Magic happens" />
  <!-- Theme color for Android/iOS -->
  <meta name=theme-color content=#800 />
  <!-- meta viewport is actually CSS hidden inside your HTML -->
  <!-- More information https://wiki.whatwg.org/wiki/MetaExtensions#viewport and https://drafts.csswg.org/css-device-adapt/#viewport-meta -->
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <!-- manifest.json is currently only supported by Chromium based browsers, as per https://www.caniuse.com/#feat=web-app-manifest -->
  <link rel=manifest href=/manifest.json />
  <link rel=icon href=/images/favicon.svg />
  <link async rel=stylesheet href=styles/layout.css />
  <link async rel=stylesheet href=styles/header.css />
  <link async rel=stylesheet href=styles/nav.css />
  <link async rel=stylesheet href=styles/main.css />
  <link async rel=stylesheet href=styles/footer.css />
</head>

<body>
  <header>
    <div id=banner-logo>
      <a href="/">
        <img loading=lazy height=111 width=111 src="/images/Thaumatorium.svg"
          alt="main logo consisting of a checkerboard pattern" />
      </a>
    </div>
    <div id=banner-text>
      <h1 class=title>The Thaumatorium:</h1>
      <div class=subtitle>Where the magic happens</div>
      <p><sub>Last updated: <time>2020-06-11</time></sub></p>
      <script>
        let previousUpdates = ["2020-05-11", "2020-05-09", "2020-05-02"]
      </script>
    </div>
  </header>

  <nav>
    <!-- `this` refers to the anchor element. `hash` refers to the `#xxxx` of the `href` attribute -->
    <!-- You can't use `this.href`, because that returns the full URL and we only want the hash -->
    <a href>Frontpage</a>
    <a href=pages/articles.html>Articles</a>
    <a href=pages/projects.html>Projects</a>
    <a href=pages/experimentations.html>Experimentations</a>
    <a href=pages/todo.html>TODO</a>
    <a href=pages/about.html>About</a>
  </nav>

  <main>
    <section>
      <h1>Haskell’s fold functions explained</h1>
      <p>Published: <time datetime=2019-05-01>2019-05-01</time></p>
      <p>Author: <span>NostraDavid</span></p>
      <p>Protip: Use https://repl.it/ to run your own little test programs, yes they support other languages than
        Haskell
        too.</p>
      <p>Haskell’s fold functions are Higher Order and Recursive functions (if you’ve read <a
          href=https://thaumatorium.wordpress.com/2018/10/15/types-or-classes-of-haskell-functions />Types (or classes)
        of
        Haskell functions</a>, you’ll know what that is) where it takes a function, a first/final item (more on this
        later),
        a list of things and returns a single reduces item.</p>
      <h2>Foldr</h2>
      <pre>
foldr :: (a -> b -> b) -> b -> [a] -> b
foldr f z []     = z
foldr f z (x:xs) = f x (foldr f z xs)
</pre>
      <p>There are two cases:</p>
      <ul>
        <li>The base case (where the input list is empty)</li>
        <li>The general case (where the input list is not empty), one items gets reduced and the function is recursively
          called on the rest of the list.</li>
      </ul>
      <p>Now lets run foldr:</p>
      <p><code>foldr (+) 0 [1,2,3,4]</code></p>
      <p>As you notice the + operator is placed in parentheses. This is to prevent the direct application of +. When
        you’re
        actually run command above without the parentheses you’ll see you’ll get an error. (try it on the pre-mentioned
        https://repl.it/ website!)</p>
      <p>The answer is 10, as 1 + 2 + 3 + 4 = 10, but what’s that 0 doing there? That is the identity value for +. I
        haven’t
        written an article about the identity value for operators (or functions), but here’s what you need to know: The
        identity value of a function means that if you put any other value in, you’ll get that value back out: x + 0 =
        x.
      </p>
      <p>Other operators may have different values:<br>
        Subtraction (-) has 0 (x – 0 = x) as identity<br>
        Multiplication (*) has 1 (multiplying by 0 would always give you 0, which is unwanted behavior) as identity<br>
        Division (/) has 1 as identity<br>
        Exponentiation (^) (aka “the power operator”) also has 1 as identity value.<br>
        f() where f outputs a list has the empty list ([]) as identity</p>
      <p>But how is 10 calculated? Since the function is called fold <strong>right</strong>, we know two things: all
        grouped
        parentheses (more on that below the executed code) are on the right and the identity value will be the last
        value
        inserted.</p>
      <p>If I run the code by hand (if you’ve ever followed a Logic course, you’ll recognize this as
        <strong>induction</strong>) we’ll get the following execution:</p>
      <pre>
foldr (+) 0 [1,2,3,4]
= { apply foldr, since the input is not an empty list we apply the general case }
(+) 1 (foldr (+) 0 [2,3,4])
= { apply foldr, ditto as before }
(+) 1 ((+) 2 (foldr (+) 0 [3,4]))
= { apply foldr, ditto as before }
(+) 1 ((+) 2 ((+) 3 (foldr (+) 0 [4])))
= { apply foldr, ditto as before }
(+) 1 ((+) 2 ((+) 3 ((+) 4 (foldr (+) 0 []))))
= { apply foldr, but since the list is now empty, return the identity value instead! }
(+) 1 ((+) 2 ((+) 3 ((+) 4 0)))
= { apply the most inner + operator }
(+) 1 ((+) 2 ((+) 3 4))
= { apply the most inner + operator }
(+) 1 ((+) 2 7)
= { apply the most inner + operator }
(+) 1 9
= { apply the most last + operator }
10
</pre>
      <p>Now when you take a look at the moment all foldrs have been applied, you may see you can rewrite that line
        from:
      </p>
      <p><code>(+) 1 ((+) 2 ((+) 3 ((+) 4 0)))</code></p>
      <p>to</p>
      <p><code>1 + (2 + (3 + (4 + 0)))</code></p>
      <p>which is more readable (IMO). Now, for this instance, the order of execution doesn’t matter at all, but there
        are
        certain operators (like subtraction and division) where the order does matter! 1/2 = .5, whereas 2/1 = 2</p>
      <p>Lets say we execute the next line, what will the answer be?</p>
      <p><code>foldr (-) 0 [1,2,3,4]</code></p>
      <p>Lets simplify the executed code above to that cleaned up line right below it:</p>
      <p><code>1 - (2 - (3 - (4 - 0)))</code></p>
      <p>As I’ve mentioned before: all grouped parentheses are grouped on the right (because fold right) and the
        identity
        value is also on the right.</p>
      <p>When we run this code we get:</p>
      <pre>
1 - (2 - (3 - (4 - 0)))
= { apply the most inner - }
1 - (2 - (3 - 4))
= { apply the most inner -. Negative values must be wrapped in parentheses }
1 - (2 - (-1))
= { apply the most inner -. Subtracting a negative number is the same as adding it  }
1 - 3
= { apply the last - }
-2
</pre>
      <h2>Foldl</h2>
      <p>Definition (again from Wikipedia):</p>
      <pre>
foldl :: (b -> a -> b) -> b -> [a] -> b
foldl f z [] = z
foldl f z (x:xs) = foldl f (f z x) xs
</pre>
      <p>What is different? The input function has its first types flipped and in the general case you can see that the
        application of f is moved into location of what was the identity value.</p>
      <p>Lets run the same code we did last time:</p>
      <pre>
foldl (-) 0 [1,2,3,4]
= { apply foldl. Again the list isn't empty, so we'll apply the general case }
foldl (-) ((-) 0 1) [2,3,4]
= { apply foldl. ditto }
foldl (-) ((-) ((-) 0 1) 2) [3,4]
= { apply foldl. ditto }
foldl (-) ((-) ((-) ((-) 0 1) 2) 3) [4]
= { apply foldl. ditto }
foldl (-) ((-) ((-) ((-) ((-) 0 1) 2) 3) 4) []
= { apply foldl. Again, the list is now empty, so apply the base case }
(-) ((-) ((-) ((-) 0 1) 2) 3) 4
= { apply the most inner - }
(-) ((-) ((-) (-1) 2) 3) 4
= { apply the most inner - }
(-) ((-) (-3) 3) 4
= { apply the most inner - }
(-) (-6) 4
= { apply the last - }
(-10)
</pre>
      <p>Now, after you’ve applied all foldls, we, again, can clean up that code:</p>
      <p><code>(-) ((-) ((-) ((-) 0 1) 2) 3) 4</code></p>
      <p><code>(((0 - 1) - 2) - 3) - 4</code></p>
      <p>There, much more readable! As you’ll notice, the grouped parentheses are now all left (from the name fold
        left),
        ditto for the identity value.</p>
      <p>Sometimes you have to rewrite code to make it make sense in Haskell. It’s a sad fact of life. Anyway, if we
        reduce
        this cleaned up code we’ll get:</p>
      <pre>
(((0 - 1) - 2) - 3) - 4
= { apply most inner - }
(((-1) - 2) - 3) - 4
= { apply most inner - }
((-3) - 3) - 4
= { apply most inner - }
(-6) - 4
= { apply most inner - }
(-10)
</pre>
      <p>I think you’ve started seeing a pattern with Foldl/Foldr right about now: all parentheses are with the identity
        value either all left or all right – that’s how I’ve been able to easily write out most code by hand (I had to
        use
        VSCode with the Bracket Pair Colorizer 2 addon with the <code>foldl (-) 0 [1,2,3,4]</code> code to check my
        parentheses :p )</p>
      <p>If you’ve got any questions (especially when you don’t understand a part), let me know down below!</p>

      <h2>Alternative explanation</h2>
      <p>With either foldl or foldr, the text of the list gets manipulated until something executable is produced:</p>
      <pre>
foldl (-) 0 [1,2,3,4]
= { add identity value to the left of the list (because fold left) }
foldl (-) [0,1,2,3,4]
= { replace all commas with the function given }
foldl [0-1-2-3-4]
= { as last, apply the parentheses, grouped to the left (because fold left). The length of the grouped parentheses is the original length of the list - 1 }
(((0-1)-2)-3)-4

</pre>
      <pre>
foldr (-) 0 [1,2,3,4]
= { add identity value to the right of the list (because fold right)
foldr (-) [1,2,3,4,0]
= { replace all commas with the function given }
foldr [1-2-3-4-0]
= { as last, apply the parentheses, grouped to the right (because fold right). The length of the grouped parentheses is the original length of the list - 1 }
1-(2-(3-(4-0)))
</pre>
    </section>
  </main>
  <footer>
    <div class="copyright">
      &copy;<a href="https://www.youtube.com/watch?v=czgOWmtGVGs" style="text-decoration: none; color: #800;">12019</a>
      &ndash; <a href="http://updateyourfooter.com/" style="text-decoration: none; color: #800;">
        <script>
          document.write(new Date().getFullYear() + 10000);
        </script>
      </a>, <abbr
        title="Copyright is implicit, almost anywhere in the world! If you want to know more, wikipedia 'Berne Convention'"
        style="text-decoration: none; color: #800;">Thaumatorium</abbr>

    </div>
    <!-- Sssh - don't tell anyone! -->
    <a class="secret" onclick=specialGoto(event)
      style="text-decoration: none; color:#800; cursor: default;font-family: sans-serif; font-size: small;">&#960;</a>
  </footer>
  <script>
    const specialGoto = (event) => {
      if (event.ctrlKey && event.shiftKey) {
        window.location.href = "/pages/praetorianpi.html";
      }
    }
  </script>
</body>

</html>